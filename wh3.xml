<?xml version="1.0" encoding="UTF-8"?><Db flnm="wh3" nm="wh3" ver="1.3.4">
  <VerLbl/>
  <VerNotes/>
  <DefTblOpts/>
  <DocFolder>C:\_SAV\projects\wh3</DocFolder>
  <Sch Cm="standard public schema" nm="public">
    <Tbl UsSo="1" nm="acls">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id, dobj" nm="pkacls"/>
      <Cl au="1" df="nextval('seq_cls_id'::regclass)" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="kind" nu="0">
        <DT arr="0" ds="SmallInt" en="" id="5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="1" nm="pid" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="title" nu="0">
        <DT arr="0" ds="whname" en="" id="5001" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="note" nu="1">
        <DT arr="0" ds="Text" en="" id="703" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="0" nm="pkind" nu="0">
        <DT arr="0" ds="SmallInt" en="" id="5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="1" nm="dobj" nu="1">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="NULL::character varying" nm="measure" nu="1">
        <DT arr="0" ds="whname" en="" id="5001" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="4" nm="cls_default_objid_fkey" prLkCl="id" upAc="1">
        <PrTb mn="0" nm="obj_num" oe="1" sch="public" zr="1"/>
        <CdTb mn="1" nm="acls" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="dobj" prCl="id"/>
      </Fk>
      <Fk deAc="1" nm="fk_acls__id_pid" prLkCl="id" upAc="1">
        <PrTb mn="0" nm="acls" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="acls" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="pid" prCl="id"/>
        <ClPr cdCl="pkind" prCl="kind"/>
      </Fk>
      <Idx clu="0" ftx="0" nm="idx_acls__pid" spa="0" unq="0">
        <ClNs>pid</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_acls__title_tgm" spa="0" unq="0">
        <ClNs>title</ClNs>
        <OptTx>USING gin</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="uidx_acls__title_vcharops" spa="0" unq="1">
        <ClNs>title</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Trg del="0" eaRow="1" exBe="1" ins="0" nm="tr_bu_acls" upd="1">
        <Sql>ftr_bu_acls()</Sql>
      </Trg>
      <UniqueConstraints>
        <UnCon nm="pk_acls__id_kind">
          <ClNs>id, kind</ClNs>
        </UnCon>
      </UniqueConstraints>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="act">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pk_act__id"/>
      <Cl au="1" df="nextval('seq_act_id'::regclass)" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="title" nu="0">
        <DT arr="0" ds="whname" en="" id="5001" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="note" nu="1">
        <DT arr="0" ds="Text" en="" id="703" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="NULL::character varying" nm="color" nu="1">
        <DT arr="0" ds="VarChar" en="" id="12" ln="64" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="script" nu="1">
        <DT arr="0" ds="Text" en="" id="703" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Idx clu="0" ftx="0" nm="idx_act__title_tgm" spa="0" unq="0">
        <ClNs>title</ClNs>
        <OptTx>USING gin</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_act__title_vpo" spa="0" unq="0">
        <ClNs>title</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <UniqueConstraints>
        <UnCon nm="uk_act__title">
          <ClNs>title</ClNs>
        </UnCon>
      </UniqueConstraints>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="favorite_prop">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pk_favoriteprop__id"/>
      <Cl au="1" df="nextval('favorite_prop_id_seq'::regclass)" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="&quot;current_user&quot;()" nm="user_label" nu="0">
        <DT arr="0" ds="name" en="" id="5002" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="cls_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="act_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="prop_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="fk_favoriteprop__ref_act_prop" prLkCl="act_id" upAc="0">
        <PrTb mn="0" nm="ref_act_prop" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="favorite_prop" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="act_id" prCl="act_id"/>
        <ClPr cdCl="prop_id" prCl="prop_id"/>
      </Fk>
      <Fk deAc="0" nm="fk_favoriteprop__ref_class_act" prLkCl="cls_id" upAc="0">
        <PrTb mn="0" nm="ref_cls_act" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="favorite_prop" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="cls_id" prCl="cls_id"/>
        <ClPr cdCl="act_id" prCl="act_id"/>
      </Fk>
      <Fk deAc="0" nm="fk_favoriteprop__user_label" prLkCl="rolname" upAc="0">
        <PrTb mn="0" nm="wh_role" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="favorite_prop" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="user_label" prCl="rolname"/>
      </Fk>
      <UniqueConstraints>
        <UnCon nm="uk_favoriteprop__id">
          <ClNs>user_label, cls_id, act_id, prop_id</ClNs>
        </UnCon>
      </UniqueConstraints>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="lock_act">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Cl au="0" df="" nm="oid" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="pid" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="act_id" nu="1">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="lock_act_oid_pid_fkey" prLkCl="oid" upAc="0">
        <PrTb mn="0" nm="lock_obj" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="lock_act" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="oid" prCl="oid"/>
        <ClPr cdCl="pid" prCl="pid"/>
      </Fk>
      <UniqueConstraints/>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="lock_dst">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Cl au="0" df="" nm="oid" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="pid" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="dst_path" nu="1">
        <DT arr="1" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="lock_dst_oid_pid_fkey" prLkCl="oid" upAc="0">
        <PrTb mn="0" nm="lock_obj" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="lock_dst" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="oid" prCl="oid"/>
        <ClPr cdCl="pid" prCl="pid"/>
      </Fk>
      <UniqueConstraints/>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="lock_obj">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="oid, pid" nm="lock_obj__oid_pid_pkey"/>
      <Cl au="0" df="pg_backend_pid" nm="lock_session" nu="0">
        <DT arr="0" ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="&quot;current_user&quot;()" nm="lock_user" nu="0">
        <DT arr="0" ds="name" en="" id="5002" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="now()" nm="lock_time" nu="0">
        <DT arr="0" ds="TimeStampWithTimeZone" en="" id="772" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="oid" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="pid" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="path" nu="1">
        <DT arr="1" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="logid_act" nu="1">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="logid_move" nu="1">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="lock_obj_lock_user_fkey" prLkCl="rolname" upAc="0">
        <PrTb mn="0" nm="wh_role" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="lock_obj" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="lock_user" prCl="rolname"/>
      </Fk>
      <Fk deAc="0" nm="lock_obj_oid_fkey" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="obj_name" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="lock_obj" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="oid" prCl="id"/>
      </Fk>
      <Idx clu="0" ftx="0" nm="idx_lock_obj_lock_user" spa="0" unq="0">
        <ClNs>lock_user</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <UniqueConstraints/>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="log_detail_act">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Cl au="0" df="" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="act_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="prop" nu="1">
        <DT arr="0" ds="JSONB" en="" id="787" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="1" nm="log_detail_act_act_id_fkey" prLkCl="id" upAc="1">
        <PrTb mn="0" nm="act" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="log_detail_act" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="act_id" prCl="id"/>
      </Fk>
      <Fk deAc="0" nm="log_detail_act_id_fkey" prLkCl="id" upAc="1">
        <PrTb mn="0" nm="log_main" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="log_detail_act" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="id" prCl="id"/>
      </Fk>
      <Idx clu="0" ftx="0" nm="idx_logactdet__aid" spa="0" unq="0">
        <ClNs>act_id</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <UniqueConstraints>
        <UnCon nm="pk_logactdet__id">
          <ClNs>id</ClNs>
        </UnCon>
      </UniqueConstraints>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="log_detail_move">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Cl au="0" df="" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="dst_path" nu="1">
        <DT arr="1" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="qty" nu="0">
        <DT arr="0" ds="Numeric" en="" id="2" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="prop_lid" nu="1">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="log_detail_move_id_fkey" prLkCl="id" upAc="1">
        <PrTb mn="0" nm="log_main" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="log_detail_move" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="id" prCl="id"/>
      </Fk>
      <Fk deAc="2" nm="log_detail_move_prop_lid_fkey" prLkCl="id" upAc="1">
        <PrTb mn="0" nm="log_detail_act" oe="1" sch="public" zr="1"/>
        <CdTb mn="1" nm="log_detail_move" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="prop_lid" prCl="id"/>
      </Fk>
      <Idx clu="0" ftx="0" nm="idx_logmovdet__dst_cid" spa="0" unq="0">
        <ClNs>(dst_path[1][1])</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_logmovdet__dst_oid" spa="0" unq="0">
        <ClNs>(dst_path[1][2])</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_logmovdet__prop_lid" spa="0" unq="0">
        <ClNs>prop_lid</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <UniqueConstraints>
        <UnCon nm="pk_logmovdet__id">
          <ClNs>id</ClNs>
        </UnCon>
      </UniqueConstraints>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="log_main">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="log_main_pkey"/>
      <Cl au="0" df="&quot;current_user&quot;()" nm="username" nu="0">
        <DT arr="0" ds="name" en="" id="5002" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="1" df="nextval('seq_log_id'::regclass)" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="now()" nm="timemark" nu="0">
        <DT arr="0" ds="TimeStampWithTimeZone" en="" id="772" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="src_path" nu="1">
        <DT arr="1" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="obj_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="log_main_obj_id_fkey" prLkCl="id" upAc="1">
        <PrTb mn="0" nm="obj_name" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="log_main" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="obj_id" prCl="id"/>
      </Fk>
      <Fk deAc="1" nm="log_main_username_fkey" prLkCl="rolname" upAc="0">
        <PrTb mn="0" nm="wh_role" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="log_main" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="username" prCl="rolname"/>
      </Fk>
      <Idx clu="0" ftx="0" nm="idx_logmain__oid" spa="0" unq="0">
        <ClNs>obj_id</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_logmain__src_cid" spa="0" unq="0">
        <ClNs>(src_path[1][1])</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_logmain__src_oid" spa="0" unq="0">
        <ClNs>(src_path[1][2])</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_logmain__timemark" spa="0" unq="0">
        <ClNs>timemark</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Trg del="1" eaRow="1" exBe="1" ins="0" nm="tr_bd_log_main" upd="0">
        <Sql>ftr_bd_log_main()</Sql>
      </Trg>
      <UniqueConstraints/>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="obj_name">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pk_objname__id"/>
      <Cl au="0" df="" nm="cls_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="cls_kind" nu="0">
        <DT arr="0" ds="SmallInt" en="" id="5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="1" df="nextval('seq_obj_id'::regclass)" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="title" nu="0">
        <DT arr="0" ds="whname" en="" id="5001" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="move_logid" nu="1">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="act_logid" nu="1">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="prop" nu="1">
        <DT arr="0" ds="JSONB" en="" id="787" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="fk_obj__cls" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="acls" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="obj_name" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="cls_id" prCl="id"/>
        <ClPr cdCl="cls_kind" prCl="kind"/>
      </Fk>
      <Idx clu="0" ftx="0" nm="idx_objname__cid" spa="0" unq="0">
        <ClNs>cls_id</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_objname__id_cid" spa="0" unq="1">
        <ClNs>id, cls_id</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_objname__prop" spa="0" unq="0">
        <ClNs>prop</ClNs>
        <OptTx>USING gin</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_objname__title_tgm" spa="0" unq="0">
        <ClNs>title</ClNs>
        <OptTx>USING gin</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_objname__title_vpo" spa="0" unq="0">
        <ClNs>title</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <UniqueConstraints>
        <UnCon nm="obj_name_act_logid_key">
          <ClNs>act_logid</ClNs>
        </UnCon>
        <UnCon nm="uk_objname__id_cid_ckind">
          <ClNs>id, cls_id, cls_kind</ClNs>
        </UnCon>
        <UnCon nm="uk_objname__movelogid">
          <ClNs>move_logid</ClNs>
        </UnCon>
        <UnCon nm="uk_objname__title_cid">
          <ClNs>title, cls_id</ClNs>
        </UnCon>
      </UniqueConstraints>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="obj_num">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pk_objnum__id"/>
      <Cl au="0" df="" nm="cls_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="1" nm="cls_kind" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="1" nm="pid" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="fk_objnum__idclsid" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="obj_name" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="obj_num" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="id" prCl="id"/>
        <ClPr cdCl="cls_id" prCl="cls_id"/>
        <ClPr cdCl="cls_kind" prCl="cls_kind"/>
      </Fk>
      <Fk deAc="4" nm="obj_num_pid_fkey" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="obj_num" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="obj_num" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="pid" prCl="id"/>
      </Fk>
      <Idx clu="0" ftx="0" nm="idx_objnum_pid" spa="0" unq="0">
        <ClNs>pid</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Trg del="0" eaRow="1" exBe="1" ins="0" nm="tr_bu_obj_num" upd="1">
        <Sql>ftr_bu_any_obj()</Sql>
      </Trg>
      <UniqueConstraints>
        <UnCon nm="uk_objnum__id_cid">
          <ClNs>id, cls_id</ClNs>
        </UnCon>
      </UniqueConstraints>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="obj_qtyf">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Cl au="0" df="" nm="cls_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="3" nm="cls_kind" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="1" nm="pid" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="qty" nu="0">
        <DT arr="0" ds="Numeric" en="" id="2" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="fk_objqtyf__id_cid_ckind" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="obj_name" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="obj_qtyf" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="id" prCl="id"/>
        <ClPr cdCl="cls_id" prCl="cls_id"/>
        <ClPr cdCl="cls_kind" prCl="cls_kind"/>
      </Fk>
      <Fk deAc="4" nm="obj_qtyf_pid_fkey" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="obj_num" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="obj_qtyf" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="pid" prCl="id"/>
      </Fk>
      <Idx clu="0" ftx="0" nm="idx_objqtyf_id_cid" spa="0" unq="0">
        <ClNs>id, cls_id</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_objqtyf_pid" spa="0" unq="0">
        <ClNs>pid</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Trg del="0" eaRow="1" exBe="1" ins="0" nm="tr_bu_obj_num" upd="1">
        <Sql>ftr_bu_any_obj()</Sql>
      </Trg>
      <UniqueConstraints>
        <UnCon nm="uk_obj_qtyf__id_pid">
          <ClNs>id, pid</ClNs>
        </UnCon>
      </UniqueConstraints>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="obj_qtyi">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Cl au="0" df="" nm="cls_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="2" nm="cls_kind" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="1" nm="pid" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="qty" nu="0">
        <DT arr="0" ds="Numeric" en="" id="2" ln="20" sc="0" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="fk_objqtyi__id_cid_ckind" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="obj_name" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="obj_qtyi" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="id" prCl="id"/>
        <ClPr cdCl="cls_id" prCl="cls_id"/>
        <ClPr cdCl="cls_kind" prCl="cls_kind"/>
      </Fk>
      <Fk deAc="4" nm="obj_qtyi_pid_fkey" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="obj_num" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="obj_qtyi" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="pid" prCl="id"/>
      </Fk>
      <Idx clu="0" ftx="0" nm="idx_objqtyi_id_cid" spa="0" unq="0">
        <ClNs>id, cls_id</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_objqtyi_pid" spa="0" unq="0">
        <ClNs>pid</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Trg del="0" eaRow="1" exBe="1" ins="0" nm="tr_bu_obj_num" upd="1">
        <Sql>ftr_bu_any_obj()</Sql>
      </Trg>
      <UniqueConstraints>
        <UnCon nm="uk_obj_qtyi__id_pid">
          <ClNs>id, pid</ClNs>
        </UnCon>
      </UniqueConstraints>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="perm_act">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pk_permact__id"/>
      <Cl au="1" df="nextval('seq_perm_id'::regclass)" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="access_group" nu="0">
        <DT arr="0" ds="name" en="" id="5002" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="0" nm="access_disabled" nu="0">
        <DT arr="0" ds="SmallInt" en="" id="5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="script_restrict" nu="1">
        <DT arr="0" ds="Text" en="" id="703" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="cls_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="obj_id" nu="1">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="{%}" nm="src_path" nu="0">
        <DT arr="0" ds="tmppath" en="" id="5003" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="act_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="fk_permact__acess_group" prLkCl="rolname" upAc="0">
        <PrTb mn="0" nm="wh_role" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="perm_act" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="access_group" prCl="rolname"/>
      </Fk>
      <Fk deAc="0" nm="fk_permact_clsact" prLkCl="cls_id" upAc="0">
        <PrTb mn="0" nm="ref_cls_act" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="perm_act" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="cls_id" prCl="cls_id"/>
        <ClPr cdCl="act_id" prCl="act_id"/>
      </Fk>
      <Idx clu="0" ftx="0" nm="idx_permact__actid" spa="0" unq="0">
        <ClNs>act_id</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_permact__srcclsobj" spa="0" unq="0">
        <ClNs>cls_id, obj_id</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_permact__user" spa="0" unq="0">
        <ClNs>access_group</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="perm_act_src_path_idx" spa="0" unq="0">
        <ClNs>src_path</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Trg del="1" eaRow="1" exBe="0" ins="0" nm="tr_aud_perm_act" upd="1">
        <Sql>ftr_aud_perm_act()</Sql>
      </Trg>
      <Trg del="0" eaRow="1" exBe="1" ins="1" nm="tr_biu_perm_act" upd="1">
        <Sql>ftr_biu_perm_act()</Sql>
      </Trg>
      <UniqueConstraints/>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="perm_move">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pk_permmove__id"/>
      <Cl au="1" df="nextval('seq_perm_id'::regclass)" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="access_group" nu="0">
        <DT arr="0" ds="name" en="" id="5002" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="0" nm="access_disabled" nu="0">
        <DT arr="0" ds="SmallInt" en="" id="5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="script_restrict" nu="1">
        <DT arr="0" ds="Text" en="" id="703" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="src_cls_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="1" nm="src_cls_kind" nu="0">
        <DT arr="0" ds="SmallInt" en="" id="5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="src_obj_id" nu="1">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="{%}" nm="src_path" nu="0">
        <DT arr="0" ds="tmppath" en="" id="5003" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="cls_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="obj_id" nu="1">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="dst_cls_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="1" nm="dst_cls_kind" nu="0">
        <DT arr="0" ds="SmallInt" en="" id="5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="dst_obj_id" nu="1">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="{%}" nm="dst_path" nu="0">
        <DT arr="0" ds="tmppath" en="" id="5003" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="fk_permmove__acess_group" prLkCl="rolname" upAc="0">
        <PrTb mn="0" nm="wh_role" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="perm_move" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="access_group" prCl="rolname"/>
      </Fk>
      <Fk deAc="0" nm="fk_permmove__dstclsid" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="acls" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="perm_move" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="dst_cls_id" prCl="id"/>
        <ClPr cdCl="dst_cls_kind" prCl="kind"/>
      </Fk>
      <Fk deAc="0" nm="fk_permmove__srcclsid" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="acls" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="perm_move" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="src_cls_id" prCl="id"/>
        <ClPr cdCl="src_cls_kind" prCl="kind"/>
      </Fk>
      <Idx clu="0" ftx="0" nm="idx_permmove__clsobj" spa="0" unq="0">
        <ClNs>cls_id, obj_id</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_permmove__dstclsobj" spa="0" unq="0">
        <ClNs>dst_cls_id, dst_obj_id</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_permmove__srcclsobj" spa="0" unq="0">
        <ClNs>src_cls_id, src_obj_id</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_permmove__user" spa="0" unq="0">
        <ClNs>access_group</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <UniqueConstraints/>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="prop">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pk_prop__id"/>
      <Cl au="1" df="nextval('seq_prop_id'::regclass)" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="title" nu="0">
        <DT arr="0" ds="whname" en="" id="5001" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="0" nm="kind" nu="0">
        <DT arr="0" ds="SmallInt" en="" id="5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="var" nu="1">
        <DT arr="1" ds="Text" en="" id="703" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="false" nm="var_strict" nu="1">
        <DT arr="0" ds="Boolean" en="" id="16" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="4" nm="fk_prop__kind" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="prop_kind" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="prop" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="kind" prCl="id"/>
      </Fk>
      <Idx clu="0" ftx="0" nm="idx_prop__title_tgm" spa="0" unq="0">
        <ClNs>title</ClNs>
        <OptTx>USING gin</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="idx_prop__title_vpo" spa="0" unq="0">
        <ClNs>title</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <UniqueConstraints>
        <UnCon nm="uk_prop__title">
          <ClNs>title</ClNs>
        </UnCon>
      </UniqueConstraints>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="prop_cls">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pk_propcls"/>
      <Cl au="1" df="nextval('seq_prop_cls_id'::regclass)" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="cls_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="cls_kind" nu="0">
        <DT arr="0" ds="SmallInt" en="" id="5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="prop_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="val" nu="1">
        <DT arr="0" ds="Text" en="" id="703" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="fk_propcls__clsid" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="acls" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="prop_cls" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="cls_id" prCl="id"/>
        <ClPr cdCl="cls_kind" prCl="kind"/>
      </Fk>
      <Fk deAc="0" nm="fk_propcls__propid" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="prop" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="prop_cls" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="prop_id" prCl="id"/>
      </Fk>
      <UniqueConstraints>
        <UnCon nm="uk_propcls__propid_clsid">
          <ClNs>prop_id, cls_id</ClNs>
        </UnCon>
      </UniqueConstraints>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="prop_kind">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pk_propkind__id"/>
      <Cl au="0" df="" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="title" nu="0">
        <DT arr="0" ds="whname" en="" id="5001" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <UniqueConstraints/>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="ref_act_prop">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pk_refactprop__id"/>
      <Cl au="1" df="nextval('seq_ref_act_prop_id'::regclass)" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="prop_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="act_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="fk_refactprop__actid" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="act" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="ref_act_prop" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="act_id" prCl="id"/>
      </Fk>
      <Fk deAc="0" nm="fk_refactprop__propid" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="prop" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="ref_act_prop" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="prop_id" prCl="id"/>
      </Fk>
      <UniqueConstraints>
        <UnCon nm="uk_refactprop__actid_propid">
          <ClNs>act_id, prop_id</ClNs>
        </UnCon>
      </UniqueConstraints>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="ref_cls_act">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pk_refclsact__id"/>
      <Cl au="1" df="nextval('seq_ref_cls_act_id'::regclass)" nm="id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="cls_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="1" nm="cls_kind" nu="0">
        <DT arr="0" ds="SmallInt" en="" id="5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="act_id" nu="0">
        <DT arr="0" ds="BigInt" en="" id="-5" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="fk_refclsact__actid" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="act" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="ref_cls_act" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="act_id" prCl="id"/>
      </Fk>
      <Fk deAc="0" nm="fk_refclsact__clsid" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="acls" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="ref_cls_act" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="cls_id" prCl="id"/>
        <ClPr cdCl="cls_kind" prCl="kind"/>
      </Fk>
      <UniqueConstraints>
        <UnCon nm="uk_refclsact_clsid_actid">
          <ClNs>cls_id, act_id</ClNs>
        </UnCon>
      </UniqueConstraints>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="wh_auth_members">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Cl au="0" df="" nm="roleid" nu="0">
        <DT arr="0" ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="member" nu="0">
        <DT arr="0" ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Fk deAc="0" nm="fk_member_wh_auth_members" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="wh_role" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="wh_auth_members" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="member" prCl="id"/>
      </Fk>
      <Fk deAc="0" nm="fk_roleid_wh_auth_members" prLkCl="id" upAc="0">
        <PrTb mn="0" nm="wh_role" oe="1" sch="public" zr="0"/>
        <CdTb mn="1" nm="wh_auth_members" oe="0" sch="public" zr="1"/>
        <ClPr cdCl="roleid" prCl="id"/>
      </Fk>
      <Idx clu="0" ftx="0" nm="wh_auth_members_member_role_index" spa="0" unq="1">
        <ClNs>member, roleid</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Trg del="1" eaRow="1" exBe="1" ins="0" nm="tr_bd_wh_auth_members" upd="0">
        <Sql>ftr_bd_wh_auth_members()</Sql>
      </Trg>
      <Trg del="0" eaRow="1" exBe="1" ins="1" nm="tr_bi_wh_auth_members" upd="0">
        <Sql>ftr_bi_wh_auth_members()</Sql>
      </Trg>
      <Trg del="0" eaRow="1" exBe="1" ins="0" nm="tr_bu_wh_auth_members" upd="1">
        <Sql>ftr_bu_wh_auth_members()</Sql>
      </Trg>
      <UniqueConstraints>
        <UnCon nm="uk_auth_members_role_member">
          <ClNs>roleid, member</ClNs>
        </UnCon>
      </UniqueConstraints>
      <SchTrHis/>
    </Tbl>
    <Tbl UsSo="1" nm="wh_role">
      <TblOpts>WITHOUT OIDS</TblOpts>
      <Pk ClNs="id" nm="pk_id_wh_group"/>
      <Cl au="1" df="nextval('wh_role_id_seq'::regclass)" nm="id" nu="0">
        <DT arr="0" ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="rolname" nu="0">
        <DT arr="0" ds="name" en="" id="5002" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="false" nm="rolcanlogin" nu="0">
        <DT arr="0" ds="Boolean" en="" id="16" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="false" nm="rolcreaterole" nu="0">
        <DT arr="0" ds="Boolean" en="" id="16" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="'-1'::integer" nm="rolconnlimit" nu="0">
        <DT arr="0" ds="Integer" en="" id="4" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="rolpassword" nu="1">
        <DT arr="0" ds="Text" en="" id="703" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="rolvaliduntil" nu="1">
        <DT arr="0" ds="TimeStampWithTimeZone" en="" id="772" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Cl au="0" df="" nm="rolcomment" nu="1">
        <DT arr="0" ds="Text" en="" id="703" ln="null" sc="null" sg="1" un="0"/>
      </Cl>
      <Idx clu="0" ftx="0" nm="wh_role_id_rolname_idx" spa="0" unq="0">
        <ClNs>id, rolname</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Idx clu="0" ftx="0" nm="wh_role_rolname_id_idx" spa="0" unq="0">
        <ClNs>rolname, id</ClNs>
        <OptTx>USING btree</OptTx>
      </Idx>
      <Trg del="1" eaRow="1" exBe="1" ins="0" nm="tr_bd_wh_role" upd="0">
        <Sql>ftr_bd_wh_role()</Sql>
      </Trg>
      <Trg del="0" eaRow="1" exBe="1" ins="1" nm="tr_bi_wh_role" upd="0">
        <Sql>ftr_bi_wh_role()</Sql>
      </Trg>
      <Trg del="0" eaRow="1" exBe="1" ins="0" nm="tr_bu_wh_role" upd="1">
        <Sql>ftr_bu_wh_role()</Sql>
      </Trg>
      <UniqueConstraints>
        <UnCon nm="uk_groupname_wh_group">
          <ClNs>rolname</ClNs>
        </UnCon>
      </UniqueConstraints>
      <SchTrHis/>
    </Tbl>
    <Proc nm="do_act(_obj_id bigint, _act_id bigint, _prop jsonb)">
      <src>CREATE OR REPLACE FUNCTION do_act(_obj_id bigint, _act_id bigint, _prop jsonb) 
  RETURNS void AS 
$$&#13;
DECLARE&#13;
    _lock_info   RECORD;&#13;
    _last_log_id BIGINT;&#13;
    _prop_str    TEXT;&#13;
    _prop_item   TEXT;&#13;
    _curr_pathid BIGINT[];&#13;
    _cls_id      BIGINT;&#13;
    _perm_sum    INTEGER;&#13;
    _old_prop    JSONB;&#13;
&#13;
    _chk_props CURSOR IS&#13;
&#13;
SELECT distinct( ref_act_prop.prop_id) as id, pold.value&#13;
       ,all_new.id as new_id,all_new.value&#13;
       ,CASE WHEN all_new.id IS NOT NULL THEN all_new.value ELSE pold.value END AS result&#13;
       --, COALESCE( all_new.value, pold.value) as result&#13;
  FROM  ref_cls_act&#13;
  RIGHT JOIN ref_act_prop  ON ref_act_prop.act_id  = ref_cls_act.act_id&#13;
  LEFT JOIN (select key::BIGINT, value::TEXT from jsonb_each(_old_prop)) pold ON pold.key=ref_act_prop.prop_id&#13;
  LEFT JOIN(&#13;
             SELECT ref_act_prop.prop_id as id, pnew.value&#13;
             FROM  ref_cls_act&#13;
             RIGHT JOIN ref_act_prop  ON ref_act_prop.act_id  = ref_cls_act.act_id&#13;
             LEFT JOIN (select key::BIGINT, value::TEXT from jsonb_each(_prop)) pnew ON pnew.key=ref_act_prop.prop_id&#13;
             WHERE ref_cls_act.cls_id IN (SELECT id FROM get_path_cls_info(_cls_id)) AND ref_cls_act.act_id=_act_id&#13;
             AND ref_act_prop.prop_id IS NOT NULL &#13;
            ) all_new ON all_new.id=ref_act_prop.prop_id&#13;
  WHERE ref_cls_act.cls_id IN (SELECT id FROM get_path_cls_info(_cls_id)) &#13;
  AND ( (all_new.id IS NOT NULL AND all_new.value IS NOT NULL) OR (all_new.id IS NULL  AND pold.value IS NOT NULL)) ;&#13;
&#13;
BEGIN&#13;
  -- проверяем - заблокирован ли объект для действия&#13;
  SELECT * INTO _lock_info &#13;
    FROM lock_obj&#13;
    LEFT JOIN lock_act USING (oid)&#13;
    WHERE&#13;
      oid = _obj_id&#13;
      AND lock_time +'00:10:00.00' &gt; now()&#13;
      AND lock_session = pg_backend_pid()&#13;
      --AND ((src_path IS NULL AND _src_path IS NULL) OR src_path=_src_path)&#13;
      AND act_id = _act_id;&#13;
  IF NOT FOUND THEN&#13;
    RAISE EXCEPTION ' Object not locked obj_id=% ', _obj_id;&#13;
  END IF;&#13;
  -- находим текущее положение и состояние&#13;
  SELECT cls_id,prop,get_path_obj_arr_2id(pid) INTO _cls_id,_old_prop,_curr_pathid &#13;
    FROM obj WHERE id=_obj_id;&#13;
  IF NOT FOUND THEN&#13;
    RAISE EXCEPTION ' Object not exists obj_id=% ', _obj_id;&#13;
  END IF;&#13;
  _curr_pathid:=COALESCE(_curr_pathid::TEXT,'{}');&#13;
  RAISE DEBUG '_curr_pathid: %',_curr_pathid;&#13;
  -- проверяем возможность выполнения выбранного действия в текущем местоположении&#13;
    SELECT sum INTO _perm_sum FROM (&#13;
    SELECT perm.act_id , sum(access_disabled) &#13;
        FROM perm_act perm&#13;
        RIGHT JOIN wh_membership ON groupname=perm.access_group AND wh_membership.username=CURRENT_USER&#13;
      WHERE &#13;
        perm.cls_id IN(SELECT id FROM get_path_cls_info(_cls_id,0))&#13;
        AND perm.act_id = _act_id&#13;
        AND  (perm.obj_id IS NULL OR perm.obj_id = _obj_id)&#13;
        AND  _curr_pathid::TEXT LIKE perm.src_path&#13;
        --AND perm.access_group IN (SELECT groupname FROM wh_membership WHERE username=CURRENT_USER)&#13;
      GROUP BY act_id&#13;
      ) t &#13;
      WHERE t.sum=0;&#13;
&#13;
   RAISE DEBUG '_perm_sum: %',COALESCE(_perm_sum,-1);&#13;
&#13;
  IF _perm_sum IS NULL OR _perm_sum&gt;0 THEN&#13;
    RAISE EXCEPTION ' Path was changed for obj_id=% _cls_id=% _act_id=% try again ', _obj_id,_cls_id,_act_id;&#13;
  END IF;&#13;
&#13;
  FOR rec IN _chk_props LOOP&#13;
    _prop_item:= concat_ws(':',quote_ident(rec.id::TEXT), rec.result );&#13;
    _prop_str := concat_ws(',',_prop_str, _prop_item );&#13;
  END LOOP;&#13;
  _prop_str:='{'||_prop_str||'}';&#13;
  RAISE DEBUG '_prop_str: %',_prop_str;&#13;
&#13;
  INSERT INTO log_main(src_path, obj_id)&#13;
    VALUES ( _curr_pathid, _obj_id) RETURNING id INTO _last_log_id;&#13;
  INSERT INTO log_detail_act(id, act_id, prop) &#13;
    VALUES (_last_log_id,_act_id, _prop_str::JSONB);&#13;
  UPDATE obj_name SET act_logid=_last_log_id, prop=_prop_str::JSONB WHERE id=_obj_id;&#13;
&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="do_move(_oid bigint, _old_opid bigint, _new_opid bigint, _qty numeric)">
      <src>CREATE OR REPLACE FUNCTION do_move(_oid bigint, _old_opid bigint, _new_opid bigint, _qty numeric) 
  RETURNS void AS 
$$&#13;
DECLARE&#13;
  _lock_info   RECORD;&#13;
  _curr_path BIGINT[];&#13;
  _dst_path BIGINT[];&#13;
  _ckind SMALLINT;&#13;
  _act_logid BIGINT;&#13;
  &#13;
  _src_qty NUMERIC;&#13;
  _dst_qty NUMERIC;&#13;
&#13;
  _move_logid BIGINT;&#13;
BEGIN&#13;
--  определяем заблокирован ли объект для действия&#13;
  SELECT * INTO _lock_info &#13;
    FROM lock_obj&#13;
    WHERE&#13;
      oid = _oid&#13;
      AND pid = _old_opid&#13;
      AND lock_time +'00:10:00.00' &gt; now()&#13;
      AND lock_session = pg_backend_pid();&#13;
  IF NOT FOUND THEN&#13;
    RAISE EXCEPTION ' Object not locked obj_id=% ', _oid;&#13;
  END IF;&#13;
-- проверяем изменился ли текущий путь объекта&#13;
  _curr_path:=(SELECT get_path_obj_arr_2id(_old_opid));&#13;
  _curr_path:=COALESCE(_curr_path::TEXT,'{}');&#13;
  RAISE DEBUG '_curr_pathid: %',_curr_path;&#13;
  if(_curr_path&lt;&gt;_lock_info.path) THEN&#13;
    RAISE EXCEPTION ' Object src_path was changed obj_id=%, old_path=% curr_path=% '&#13;
                                             , _oid, _lock_info.path,_curr_path;&#13;
  END IF;&#13;
-- проверяем есть ли среди заблокированных пунктов назначений выбранный &#13;
  _dst_path:=get_path_obj_arr_2id(_new_opid);&#13;
  _dst_path:=COALESCE(_dst_path::TEXT,'{}');&#13;
  PERFORM FROM lock_dst WHERE oid=_oid AND pid=_old_opid AND dst_path = _dst_path &#13;
                              OR (dst_path IS NULL AND _dst_path IS NULL);&#13;
  IF NOT FOUND THEN&#13;
    RAISE EXCEPTION ' Object dst_path was changed obj_id=%, _dst_path=%'&#13;
                                             , _oid, _dst_path;&#13;
  END IF;&#13;
-- проверяем существование объекта и берём его класс&#13;
  SELECT cls_kind,act_logid,qty INTO _ckind, _act_logid,_src_qty FROM obj WHERE id=_oid AND pid=_old_opid;&#13;
  IF NOT FOUND OR _ckind IS NULL OR _ckind&lt;1 OR _ckind&gt;3 THEN&#13;
    RAISE EXCEPTION ' Object not exist obj_id=%', _oid;&#13;
  END IF;&#13;
-- находим исходное количество и количество в месте назначения&#13;
  SELECT qty INTO _dst_qty FROM obj WHERE pid=_new_opid AND id=_oid;&#13;
  RAISE DEBUG ' _dst_qty=% ',_dst_qty;&#13;
&#13;
  CASE _ckind&#13;
   WHEN 1 THEN PERFORM do_move_objnum(_oid, _new_opid);&#13;
   WHEN 2 THEN PERFORM do_move_objqtyi(_oid, _old_opid, _new_opid, _qty);&#13;
   WHEN 3 THEN PERFORM do_move_objqtyf(_oid, _old_opid, _new_opid, _qty);&#13;
   ELSE RAISE EXCEPTION 'Wrong kind or unknown error'; &#13;
  END CASE;&#13;
&#13;
  &#13;
&#13;
  &#13;
&#13;
  INSERT INTO log_main(src_path, obj_id)&#13;
      VALUES (_curr_path, _oid) RETURNING id INTO _move_logid;&#13;
  INSERT INTO log_detail_move(id, dst_path, qty, prop_lid)&#13;
      VALUES (_move_logid,  _dst_path, _qty, _act_logid);&#13;
-- обновляем ссылку на последнее действие в исходном и конечном объектах&#13;
  UPDATE obj_name SET move_logid=_move_logid  WHERE id=_oid;&#13;
&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 500;</src>
    </Proc>
    <Proc nm="do_move_objnum(_oid bigint, _new_opid bigint)">
      <src>CREATE OR REPLACE FUNCTION do_move_objnum(_oid bigint, _new_opid bigint) 
  RETURNS void AS 
$$&#13;
DECLARE&#13;
BEGIN&#13;
  RAISE DEBUG 'MOV obj_num  id=%  new_opid=%',_oid,_new_opid;&#13;
  UPDATE obj_num SET pid = _new_opid WHERE id=_oid;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="do_move_objqtyf(_oid bigint, _old_opid bigint, _new_opid bigint, _qty numeric)">
      <src>CREATE OR REPLACE FUNCTION do_move_objqtyf(_oid bigint, _old_opid bigint, _new_opid bigint, _qty numeric) 
  RETURNS void AS 
$$&#13;
DECLARE&#13;
  _src_qty NUMERIC;&#13;
  _dst_qty NUMERIC;&#13;
BEGIN&#13;
  SELECT qty INTO _dst_qty FROM obj_qtyf WHERE pid=_new_opid AND id=_oid;&#13;
  SELECT qty INTO _src_qty FROM obj_qtyf WHERE pid=_old_opid AND id=_oid;&#13;
  &#13;
  CASE&#13;
    WHEN _qty &lt; _src_qty  THEN -- div разделяем исходное количество&#13;
      RAISE DEBUG 'DIV src.qty= (% - %) WHERE id=% AND pid=%',_src_qty, _qty,_oid,_old_opid;&#13;
      UPDATE obj_qtyf SET qty= (_src_qty - _qty) WHERE pid = _old_opid AND id=_oid;      -- уменьшаем исходное количество&#13;
      IF _dst_qty IS NOT NULL THEN -- если в месте назначения есть уже такой объект&#13;
           RAISE DEBUG 'DIV dst.qty= (% + %) WHERE id=% AND pid=%',_dst_qty, _qty,_oid,_new_opid;&#13;
           UPDATE obj_qtyf SET qty= (_dst_qty + _qty) WHERE pid = _new_opid AND id=_oid; -- добавляем (обновляем имеющееся количество)&#13;
       ELSE -- если в месте назначения объекта нет&#13;
         INSERT INTO obj_qtyf(id, cls_id, cls_kind, pid, qty)&#13;
           SELECT id,cls_id,cls_kind,_new_opid,_qty FROM obj_name WHERE id=_oid;&#13;
       END IF;&#13;
    WHEN _qty = _src_qty THEN -- move перемещение&#13;
        IF _dst_qty IS NOT NULL THEN -- если в месте назначения есть уже такой объект&#13;
           UPDATE obj_qtyf SET qty= (_dst_qty + _qty) WHERE pid = _new_opid AND id=_oid;-- добавляем (обновляем имеющееся количество)&#13;
           DELETE FROM obj_qtyf WHERE pid = _old_opid AND id=_oid; -- удаляем всё с старого местоположения&#13;
        ELSE&#13;
           UPDATE obj_qtyf SET pid = _new_opid WHERE pid = _old_opid AND id=_oid;&#13;
        END IF;&#13;
    ELSE&#13;
        RAISE EXCEPTION 'Wrong qty or unknown error'; &#13;
  END CASE;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="do_move_objqtyi(_oid bigint, _old_opid bigint, _new_opid bigint, _qty numeric)">
      <src>CREATE OR REPLACE FUNCTION do_move_objqtyi(_oid bigint, _old_opid bigint, _new_opid bigint, _qty numeric) 
  RETURNS void AS 
$$&#13;
DECLARE&#13;
  _src_qty NUMERIC;&#13;
  _dst_qty NUMERIC;&#13;
BEGIN&#13;
  SELECT qty INTO _dst_qty FROM obj_qtyi WHERE pid=_new_opid AND id=_oid;&#13;
  SELECT qty INTO _src_qty FROM obj_qtyi WHERE pid=_old_opid AND id=_oid;&#13;
  RAISE DEBUG 'MOV obj_qtyi id=%  new_opid=%  _old_opid=%',_oid,_new_opid,_old_opid;&#13;
  CASE&#13;
    WHEN _qty &lt; _src_qty  THEN -- div разделяем исходное количество&#13;
      RAISE DEBUG 'DIV src.qty= (% - %) WHERE id=% AND pid=%',_src_qty, _qty,_oid,_old_opid;&#13;
      UPDATE obj_qtyi SET qty= (_src_qty - _qty) WHERE pid = _old_opid AND id=_oid;      -- уменьшаем исходное количество&#13;
      IF _dst_qty IS NOT NULL THEN -- если в месте назначения есть уже такой объект&#13;
           RAISE DEBUG 'DIV dst.qty= (% + %) WHERE id=% AND pid=%',_dst_qty, _qty,_oid,_new_opid;&#13;
           UPDATE obj_qtyi SET qty= (_dst_qty + _qty) WHERE pid = _new_opid AND id=_oid; -- добавляем (обновляем имеющееся количество)&#13;
       ELSE -- если в месте назначения объекта нет&#13;
         INSERT INTO obj_qtyi(id, cls_id, cls_kind, pid, qty)&#13;
           SELECT id,cls_id,cls_kind,_new_opid,_qty FROM obj_name WHERE id=_oid;&#13;
       END IF;&#13;
    WHEN _qty = _src_qty THEN -- move перемещение&#13;
        IF _dst_qty IS NOT NULL THEN -- если в месте назначения есть уже такой объект&#13;
           UPDATE obj_qtyi SET qty= (_dst_qty + _qty) WHERE pid = _new_opid AND id=_oid;-- добавляем (обновляем имеющееся количество)&#13;
           DELETE FROM obj_qtyi WHERE pid = _old_opid AND id=_oid;-- удаляем всё с старого местоположения&#13;
        ELSE&#13;
           UPDATE obj_qtyi SET pid = _new_opid WHERE pid = _old_opid AND id=_oid;&#13;
        END IF;&#13;
    ELSE&#13;
        RAISE EXCEPTION 'Wrong qty or unknown error'; &#13;
  END CASE;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="fn_array1_to_table(IN  anyarray)">
      <src>CREATE OR REPLACE FUNCTION fn_array1_to_table(IN "" anyarray) 
  RETURNS TABLE(idx integer, id anyelement) AS 
$$ &#13;
  SELECT row, $1[row] from generate_subscripts($1, 1) as row&#13;
$$
  LANGUAGE sql IMMUTABLE 
  COST 100
  ROWS 1000;</src>
    </Proc>
    <Proc nm="fn_array2_to_table(IN  anyarray)">
      <src>CREATE OR REPLACE FUNCTION fn_array2_to_table(IN "" anyarray) 
  RETURNS TABLE(idx integer, id1 anyelement, id2 anyelement) AS 
$$ &#13;
  SELECT row, $1[row][1],$1[row][2] from generate_subscripts($1, 1) as row&#13;
$$
  LANGUAGE sql IMMUTABLE 
  COST 100
  ROWS 1000;</src>
    </Proc>
    <Proc nm="ftg_del_log()">
      <src>CREATE OR REPLACE FUNCTION ftg_del_log() 
  RETURNS trigger AS 
$$&#13;
BEGIN&#13;
  DELETE FROM log_main WHERE id = OLD.log_id;&#13;
  RETURN OLD;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="ftg_del_obj()">
      <src>CREATE OR REPLACE FUNCTION ftg_del_obj() 
  RETURNS trigger AS 
$$&#13;
DECLARE&#13;
  _kind SMALLINT;&#13;
BEGIN&#13;
  SELECT kind INTO _kind FROM acls WHERE id=OLD.cls_id;-- _kind находим сами не пользуя NEW.kind&#13;
  IF NOT FOUND THEN&#13;
    RAISE EXCEPTION ' %: cls.id=% not present in cls_real',TG_NAME, OLD.cls_id ;&#13;
  END IF;&#13;
&#13;
  CASE _kind&#13;
    WHEN 1 THEN DELETE FROM obj_name  WHERE id = OLD.id;&#13;
    WHEN 2 THEN DELETE  FROM obj_qtyi WHERE id = OLD.id AND pid=OLD.pid;&#13;
                PERFORM FROM obj_qtyi WHERE id = OLD.id;&#13;
                IF NOT FOUND THEN&#13;
                  DELETE FROM obj_name WHERE id=OLD.id;&#13;
                END IF;&#13;
    WHEN 3 THEN DELETE  FROM obj_qtyf WHERE id = OLD.id AND pid=OLD.pid;&#13;
                PERFORM FROM obj_qtyf WHERE id = OLD.id;&#13;
                IF NOT FOUND THEN&#13;
                  DELETE FROM obj_name WHERE id=OLD.id;&#13;
                END IF;&#13;
    ELSE RAISE EXCEPTION ' %: wrong kind %',TG_NAME,_kind ;&#13;
  END CASE;&#13;
RETURN OLD;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="ftg_ins_obj()">
      <src>CREATE OR REPLACE FUNCTION ftg_ins_obj() 
  RETURNS trigger AS 
$$&#13;
DECLARE&#13;
  _kind SMALLINT;&#13;
BEGIN&#13;
  SELECT kind INTO _kind FROM acls WHERE id=NEW.cls_id;-- _kind находим сами не пользуя NEW.kind&#13;
  IF NOT FOUND THEN&#13;
    RAISE EXCEPTION ' %: cls.id=% not present in cls table',TG_NAME, NEW.cls_id ;&#13;
  END IF;&#13;
&#13;
  NEW.id := COALESCE(NEW.id,nextval('seq_obj_id'));&#13;
&#13;
  PERFORM FROM obj WHERE id=NEW.id;-- проверяем существование количественного объета&#13;
  IF NOT FOUND THEN&#13;
    INSERT INTO obj_name(id, title, cls_id,cls_kind)VALUES(NEW.id, NEW.title, NEW.cls_id,_kind);&#13;
  END IF;&#13;
  &#13;
  CASE _kind&#13;
    WHEN 1 THEN INSERT INTO obj_num(id,cls_id, pid)VALUES (NEW.id,NEW.cls_id,NEW.pid);NEW.qty:=1;&#13;
    WHEN 2 THEN &#13;
      IF (ceil(NEW.qty)&lt;&gt;NEW.qty)THEN&#13;
        RAISE EXCEPTION ' qty is not integer NEW.qty=%', NEW.qty;&#13;
      END IF;&#13;
      INSERT INTO obj_qtyi(id,cls_id, pid, qty) VALUES (NEW.id,NEW.cls_id,NEW.pid,NEW.qty);&#13;
    WHEN 3 THEN INSERT INTO obj_qtyf(id,cls_id, pid, qty) VALUES (NEW.id,NEW.cls_id,NEW.pid,NEW.qty);&#13;
    ELSE RAISE EXCEPTION ' %: wrong kind = %',TG_NAME , _kind ;&#13;
  END CASE;&#13;
  RETURN NEW;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="ftg_upd_obj()">
      <src>CREATE OR REPLACE FUNCTION ftg_upd_obj() 
  RETURNS trigger AS 
$$&#13;
DECLARE&#13;
  _kind SMALLINT;&#13;
BEGIN&#13;
  SELECT kind INTO _kind FROM acls WHERE id=NEW.cls_id;-- _kind находим сами не пользуя NEW.kind&#13;
  IF NOT FOUND THEN&#13;
    RAISE EXCEPTION ' %: cls.id=% not present in cls_real',TG_NAME, NEW.cls_id ;&#13;
  END IF;&#13;
  &#13;
  IF NEW.id&lt;&gt;OLD.id OR NEW.cls_id&lt;&gt;OLD.cls_id THEN&#13;
    RAISE EXCEPTION ' %: can`t change id/cls_id',TG_NAME;&#13;
  END IF;&#13;
&#13;
  IF _kind&gt;0 AND _kind&lt;4 THEN&#13;
    UPDATE obj_name SET &#13;
      title=NEW.title&#13;
      ,move_logid=NEW.move_logid &#13;
      ,act_logid=NEW.act_logid&#13;
      ,prop=NEW.prop&#13;
      WHERE id =  NEW.id;&#13;
  END IF;&#13;
&#13;
   RAISE DEBUG '%: NEW=% OLD=%',TG_NAME,NEW,OLD;&#13;
&#13;
  CASE _kind&#13;
    WHEN 1 THEN &#13;
      UPDATE obj_num  SET pid=NEW.pid WHERE id =  NEW.id;&#13;
    WHEN 2 THEN &#13;
      IF (ceil(NEW.qty)&lt;&gt;NEW.qty)THEN&#13;
        RAISE EXCEPTION ' qty is not integer NEW.qty=%', NEW.qty;&#13;
      END IF;&#13;
      UPDATE obj_qtyi SET pid=NEW.pid, qty=NEW.qty WHERE id = NEW.id AND pid=OLD.pid;&#13;
    WHEN 3 THEN &#13;
      RAISE DEBUG '%: UPDATE obj_qtyf SET pid=%, qty=% WHERE id = % AND pid=%',TG_NAME,NEW.pid,NEW.qty,NEW.id,OLD.pid;&#13;
      UPDATE obj_qtyf SET pid=NEW.pid, qty=NEW.qty WHERE id = NEW.id AND pid=OLD.pid;&#13;
    ELSE RAISE EXCEPTION ' %: wrong kind %',TG_NAME,NEW_kind ;&#13;
  END CASE;&#13;
RETURN NEW;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="ftr_aud_perm_act()">
      <src>CREATE OR REPLACE FUNCTION ftr_aud_perm_act() 
  RETURNS trigger AS 
$$&#13;
DECLARE&#13;
BEGIN&#13;
  IF TG_OP='DELETE' OR (TG_OP='UPDATE' AND (NEW.cls_id&lt;&gt;OLD.cls_id OR NEW.act_id&lt;&gt;OLD.act_id)) THEN&#13;
    DELETE FROM ref_cls_act WHERE (act_id, cls_id) NOT IN (&#13;
                SELECT act_id, cls_id FROM perm_act GROUP BY act_id, cls_id );&#13;
  END IF;&#13;
RETURN OLD;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="ftr_bd_log_main()">
      <src>CREATE OR REPLACE FUNCTION ftr_bd_log_main() 
  RETURNS trigger AS 
$$&#13;
DECLARE&#13;
  _lock_info       RECORD;&#13;
  _rec_detail_act  RECORD;&#13;
  prev_act_log_id  BIGINT;&#13;
  prev_prop        JSONB;&#13;
&#13;
  _old_detail_move RECORD;&#13;
  _ckind           SMALLINT;&#13;
  _oid             BIGINT;&#13;
  _old_opid        BIGINT;&#13;
  _new_opid        BIGINT;&#13;
  _qty             NUMERIC;&#13;
  _prev_mov_log_id BIGINT;&#13;
  &#13;
  &#13;
BEGIN&#13;
  IF OLD.timemark &lt; CURRENT_TIMESTAMP - '3 00:00:00'::interval THEN&#13;
    RAISE EXCEPTION ' %: can`t delete time is up log_rec=% ',TG_NAME, OLD;&#13;
  END IF;&#13;
  IF OLD.username &lt;&gt; CURRENT_USER THEN&#13;
    RAISE EXCEPTION ' %: can`t delete wrong user log_rec=% ',TG_NAME, OLD;&#13;
  END IF;&#13;
  PERFORM FROM log_main WHERE obj_id=OLD.obj_id AND timemark &gt; OLD.timemark;&#13;
  IF FOUND THEN&#13;
    RAISE EXCEPTION ' %: can`t delete log was updated log_rec=%',TG_NAME, OLD;&#13;
  END IF;&#13;
&#13;
  SELECT * INTO _rec_detail_act FROM log_detail_act WHERE id=OLD.id;&#13;
  IF FOUND THEN&#13;
    SELECT log_main.id, log_detail_act.prop INTO prev_act_log_id, prev_prop &#13;
      FROM log_main&#13;
      INNER JOIN log_detail_act USING (id)&#13;
      WHERE obj_id=OLD.obj_id AND timemark &lt; OLD.timemark&#13;
      ORDER BY timemark DESC LIMIT 1;&#13;
&#13;
    UPDATE obj_name SET act_logid = prev_act_log_id, prop = prev_prop&#13;
      WHERE id=OLD.obj_id;&#13;
  END IF;&#13;
&#13;
  SELECT * INTO _old_detail_move FROM log_detail_move WHERE id=OLD.id;&#13;
  IF FOUND THEN&#13;
    _oid:=OLD.obj_id;&#13;
    _old_opid:=_old_detail_move.dst_path[1][2];&#13;
    _new_opid:=OLD.src_path[1][2];&#13;
    _qty := _old_detail_move.qty;&#13;
    SELECT cls_kind INTO _ckind FROM obj_name WHERE id=_oid;&#13;
    &#13;
    -- Ищем непросроченые чужие блокировки&#13;
    SELECT * INTO _lock_info &#13;
      FROM lock_obj&#13;
      WHERE&#13;
      oid = _oid&#13;
      AND now() &lt; lock_time +'00:10:00.00' AND lock_session &lt;&gt; pg_backend_pid()&#13;
      AND ( &#13;
            _ckind=1&#13;
            OR --Если обьект относится к количественным, то надо проверить в таблице блокировок текущее место и предыдущее&#13;
            ( _ckind&lt;&gt;1 &#13;
              AND &#13;
              (pid = _old_opid OR pid=_new_opid) &#13;
            )&#13;
          )&#13;
    ;&#13;
    IF FOUND THEN -- отменяем откат действия если стоит блокировка&#13;
      RAISE EXCEPTION ' %: can`t delete object(id=%) is locked by user % in %.'&#13;
        ,TG_NAME, _oid, _lock_info.lock_user, _lock_info.lock_time;&#13;
    END IF;&#13;
&#13;
    CASE _ckind&#13;
      WHEN 1 THEN PERFORM do_move_objnum(_oid, _new_opid);&#13;
      WHEN 2 THEN PERFORM do_move_objqtyi(_oid, _old_opid, _new_opid, _qty);&#13;
      WHEN 3 THEN PERFORM do_move_objqtyf(_oid, _old_opid, _new_opid, _qty);&#13;
      ELSE RAISE EXCEPTION 'Wrong kind or unknown error'; &#13;
    END CASE;&#13;
    SELECT id INTO _prev_mov_log_id &#13;
      FROM log_main&#13;
      INNER JOIN log_detail_move USING (id)&#13;
      WHERE obj_id=_oid AND timemark &lt; OLD.timemark&#13;
      ORDER BY timemark DESC LIMIT 1;&#13;
    UPDATE obj_name SET move_logid=_prev_mov_log_id WHERE id=_oid;&#13;
  END IF;&#13;
&#13;
RETURN OLD;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="ftr_bd_wh_auth_members()">
      <src>CREATE OR REPLACE FUNCTION ftr_bd_wh_auth_members() 
  RETURNS trigger AS 
$$&#13;
DECLARE&#13;
	_role VARCHAR;&#13;
	_user VARCHAR;&#13;
	_pg_createrole boolean;&#13;
BEGIN&#13;
	SELECT rolname INTO _role FROM wh_role WHERE wh_role.id=OLD.roleid;&#13;
	SELECT rolname INTO _user FROM wh_role WHERE wh_role.id=OLD.member;&#13;
	IF _role IS NOT NULL AND _user IS NOT NULL&#13;
		THEN EXECUTE 'REVOKE '||quote_ident(_role)||' FROM '||quote_ident(_user);&#13;
	END IF;&#13;
&#13;
	--если пользователь админ и хочет дать права админу кому-то ещё проверяем в PG его принадлежность к админам&#13;
	SELECT rolcreaterole INTO _pg_createrole FROM pg_authid WHERE rolname=CURRENT_USER;&#13;
	IF _role='Admin' AND _pg_createrole IS TRUE&#13;
	THEN&#13;
		UPDATE wh_role SET rolcreaterole=false WHERE wh_role.id= OLD.member;&#13;
	END IF;&#13;
&#13;
	&#13;
	RETURN OLD;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="ftr_bd_wh_role()">
      <src>CREATE OR REPLACE FUNCTION ftr_bd_wh_role() 
  RETURNS trigger AS 
$$&#13;
BEGIN&#13;
	--BEGIN&#13;
		EXECUTE 'DROP ROLE IF EXISTS '||quote_ident(OLD.rolname);&#13;
		RAISE NOTICE USING MESSAGE ='DROP ROLE IF EXISTS '||quote_ident(OLD.rolname);&#13;
	--EXCEPTION&#13;
	--	WHEN object_in_use THEN RAISE NOTICE 'can not delete role % - object_in_use',OLD.rolname;&#13;
	--	WHEN dependent_objects_still_exist THEN RAISE NOTICE 'can not delete role % - dependent_objects_still_exist',OLD.rolname;&#13;
	--END;	&#13;
&#13;
RETURN OLD;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="ftr_bi_wh_auth_members()">
      <src>CREATE OR REPLACE FUNCTION ftr_bi_wh_auth_members() 
  RETURNS trigger AS 
$$&#13;
DECLARE&#13;
	_role VARCHAR;&#13;
	_user VARCHAR;&#13;
BEGIN&#13;
	SELECT rolname INTO _role FROM wh_role WHERE wh_role.id=NEW.roleid;&#13;
	SELECT rolname INTO _user FROM wh_role WHERE wh_role.id=NEW.member;&#13;
&#13;
	IF _role IS NOT NULL AND _user IS NOT NULL&#13;
	THEN &#13;
		EXECUTE 'GRANT '||quote_ident(_role)||' TO '||quote_ident(_user);&#13;
	END IF;&#13;
&#13;
	IF _role='Admin' &#13;
	THEN&#13;
		UPDATE wh_role SET rolcreaterole=true WHERE wh_role.id= NEW.member;&#13;
	END IF;&#13;
	&#13;
RETURN NEW;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="ftr_bi_wh_role()">
      <src>CREATE OR REPLACE FUNCTION ftr_bi_wh_role() 
  RETURNS trigger AS 
$$&#13;
BEGIN&#13;
	LOOP&#13;
		EXIT WHEN (SELECT id FROM wh_role WHERE id=NEW.id) IS NULL;  --!!!ограничить число переборов на случай полного заполнения&#13;
		SELECT nextval('wh_role_id_seq') INTO NEW.id;&#13;
		RAISE NOTICE 'searching id : NEW.id=%',NEW.id; -- отменяем попытку переноса&#13;
	END LOOP;&#13;
&#13;
	RAISE NOTICE USING MESSAGE ='CREATE ROLE '||quote_ident(NEW.rolname)||' NOSUPERUSER INHERIT NOCREATEDB '&#13;
			||CASE WHEN NEW.rolcanlogin 	THEN ' LOGIN' 		ELSE ' NOLOGIN' END&#13;
			||CASE WHEN NEW.rolcreaterole 	THEN ' CREATEROLE' 	ELSE ' NOCREATEROLE' END&#13;
			||' CONNECTION LIMIT '|| NEW.rolconnlimit&#13;
			||CASE WHEN NEW.rolpassword IS NULL THEN ' '		ELSE ' ENCRYPTED PASSWORD '||quote_literal(NEW.rolpassword) END&#13;
			||CASE WHEN NEW.rolvaliduntil IS NULL THEN ' '		ELSE ' VALID UNTIL '||quote_literal(NEW.rolvaliduntil)END;&#13;
			&#13;
	EXECUTE 'CREATE ROLE '||quote_ident(NEW.rolname)||' NOSUPERUSER INHERIT NOCREATEDB '&#13;
			||CASE WHEN NEW.rolcanlogin 		THEN ' LOGIN' 		ELSE ' NOLOGIN' END&#13;
			||CASE WHEN NEW.rolcreaterole 		THEN ' CREATEROLE' 	ELSE ' NOCREATEROLE' END&#13;
			||' CONNECTION LIMIT '|| NEW.rolconnlimit&#13;
			||CASE WHEN NEW.rolpassword IS NULL 	THEN ' '		ELSE ' ENCRYPTED PASSWORD '||quote_literal(NEW.rolpassword) END&#13;
			||CASE WHEN NEW.rolvaliduntil IS NULL 	THEN ' '		ELSE ' VALID UNTIL '||quote_literal(NEW.rolvaliduntil)END;&#13;
&#13;
	IF(NEW.rolcomment IS NOT NULL)&#13;
	THEN&#13;
		EXECUTE 'COMMENT ON ROLE '||quote_ident(NEW.rolname)||' IS '||quote_literal(NEW.rolcomment);&#13;
		RAISE NOTICE USING MESSAGE ='COMMENT ON ROLE '||quote_ident(NEW.rolname)||' IS '||quote_literal(NEW.rolcomment);&#13;
	END IF;&#13;
&#13;
	RETURN NEW;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="ftr_biu_perm_act()">
      <src>CREATE OR REPLACE FUNCTION ftr_biu_perm_act() 
  RETURNS trigger AS 
$$&#13;
DECLARE&#13;
&#13;
BEGIN&#13;
  IF TG_OP='INSERT' OR TG_OP='UPDATE' THEN&#13;
        PERFORM * FROM ref_cls_act WHERE cls_id = NEW.cls_id AND act_id = NEW.act_id;&#13;
        -- если не нашлось, то добавляем &#13;
        IF NOT FOUND THEN&#13;
            INSERT INTO ref_cls_act(cls_id, act_id,cls_kind) VALUES (NEW.cls_id, NEW.act_id,(SELECT kind FROM acls WHERE id=NEW.cls_id));&#13;
        END IF;&#13;
  END IF;&#13;
&#13;
RETURN NEW;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="ftr_bu_acls()">
      <src>CREATE OR REPLACE FUNCTION ftr_bu_acls() 
  RETURNS trigger AS 
$$&#13;
DECLARE&#13;
BEGIN&#13;
  -- Проверяем, что никто не пытается изменить тип класса или идентификатор&#13;
  IF NEW.id&lt;&gt;OLD.id OR NEW.kind&lt;&gt;OLD.kind THEN&#13;
    RAISE EXCEPTION ' %: can`t change id and kind',TG_NAME;&#13;
  END IF;&#13;
  -- Если произошло изменение родителя узла&#13;
  IF NEW.pid &lt;&gt; OLD.pid THEN&#13;
  -- Пытаемся найти в родителькой ветки нового родителя текущий узел&#13;
    PERFORM FROM get_path_cls_info(NEW.pid) WHERE id = OLD.id;&#13;
    IF FOUND THEN&#13;
      RAISE EXCEPTION ' %: can`t change pid - cycling error',TG_NAME;&#13;
    END IF;&#13;
  END IF;&#13;
RETURN NEW;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="ftr_bu_any_obj()">
      <src>CREATE OR REPLACE FUNCTION ftr_bu_any_obj() 
  RETURNS trigger AS 
$$&#13;
DECLARE&#13;
BEGIN&#13;
-- Если произошло изменение родителя узла&#13;
  IF NEW.pid IS NOT NULL AND (NEW.pid &lt;&gt; OLD.pid OR OLD.pid IS NULL) THEN&#13;
  -- Пытаемся найти в родителькой ветки нового родителя текущий узел&#13;
    PERFORM FROM get_path_obj_info(NEW.pid) WHERE oid = OLD.id;&#13;
    IF FOUND THEN&#13;
      RAISE EXCEPTION ' %: can`t change pid - cycling error',TG_NAME;&#13;
    END IF;&#13;
  END IF;&#13;
RETURN NEW;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="ftr_bu_wh_auth_members()">
      <src>CREATE OR REPLACE FUNCTION ftr_bu_wh_auth_members() 
  RETURNS trigger AS 
$$&#13;
BEGIN&#13;
	--RAISE EXCEPTION 'Невозможно изменить данные в wh_auth_members только вставка и удаление';&#13;
	RETURN NEW;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="ftr_bu_wh_role()">
      <src>CREATE OR REPLACE FUNCTION ftr_bu_wh_role() 
  RETURNS trigger AS 
$$&#13;
BEGIN&#13;
	IF NEW.id&lt;&gt;OLD.id &#13;
		THEN RAISE EXCEPTION 'Невозможно изменить пользователя %, смена id недопустима!',OLD.rolname;  &#13;
		END IF;&#13;
	IF NEW.rolcanlogin&lt;&gt;OLD.rolcanlogin&#13;
		THEN RAISE EXCEPTION 'Невозможно изменить пользователя %, смена типа недопустима(пользователь/группа) недопустима!',OLD.rolname;  &#13;
		END IF;&#13;
&#13;
&#13;
	IF NEW.rolcreaterole&lt;&gt;OLD.rolcreaterole&#13;
		THEN EXECUTE 'ALTER ROLE '||quote_ident(OLD.rolname)|| CASE WHEN NEW.rolcreaterole THEN ' CREATEROLE' 	ELSE ' NOCREATEROLE' END;&#13;
		RAISE NOTICE USING MESSAGE = 'ALTER ROLE '||quote_ident(OLD.rolname)|| CASE WHEN NEW.rolcreaterole THEN ' CREATEROLE' 	ELSE ' NOCREATEROLE' END;&#13;
		END IF;&#13;
	IF NEW.rolconnlimit&lt;&gt;OLD.rolconnlimit&#13;
		THEN EXECUTE 'ALTER ROLE '||quote_ident(OLD.rolname)||' CONNECTION LIMIT '||NEW.rolconnlimit;&#13;
		END IF;&#13;
  IF NEW.rolpassword&lt;&gt;OLD.rolpassword THEN &#13;
    EXECUTE 'ALTER ROLE '||quote_ident(OLD.rolname)||' ENCRYPTED PASSWORD '||quote_literal(NEW.rolpassword);&#13;
  END IF;&#13;
	IF NEW.rolvaliduntil&lt;&gt;OLD.rolvaliduntil&#13;
		THEN EXECUTE 'ALTER ROLE '||quote_ident(OLD.rolname)||' VALID UNTIL '||quote_literal(rolvaliduntil);&#13;
		END IF;&#13;
	IF NEW.rolcomment&lt;&gt;OLD.rolcomment&#13;
		THEN EXECUTE 'COMMENT ON ROLE '||quote_ident(OLD.rolname)||' IS '||quote_literal(NEW.rolcomment);&#13;
		END IF;&#13;
	IF NEW.rolname&lt;&gt;OLD.rolname&#13;
		THEN EXECUTE 'ALTER ROLE '||quote_ident(OLD.rolname)||' RENAME TO '||quote_ident(NEW.rolname);&#13;
		RAISE NOTICE USING MESSAGE = 'ALTER ROLE '||quote_ident(OLD.rolname)||' RENAME TO '||quote_ident(NEW.rolname);&#13;
		END IF;&#13;
	&#13;
&#13;
  RAISE DEBUG 'UPDATE wh_role RECORD (%)', NEW;&#13;
&#13;
RETURN NEW;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <Proc nm="get_childs_cls(IN _obj_id bigint)">
      <src>CREATE OR REPLACE FUNCTION get_childs_cls(IN _obj_id bigint) 
  RETURNS TABLE(_id bigint, _title whname, _kind smallint, _pid bigint, _note text, _measure whname, _dobj bigint) AS 
$$ &#13;
BEGIN&#13;
RETURN QUERY(&#13;
    WITH RECURSIVE children AS (&#13;
    SELECT id,  title, kind, pid,  note, measure,dobj&#13;
           ,ARRAY[id]                            AS exist&#13;
           ,FALSE                                AS cycle&#13;
    FROM acls&#13;
    WHERE id = _obj_id&#13;
    UNION ALL&#13;
        SELECT t.id, t.title, t.kind, t.pid, t.note, t.measure, t.dobj&#13;
               ,exist || t.id &#13;
               ,t.id = ANY(exist)&#13;
        FROM children AS c, &#13;
             acls  AS t&#13;
        WHERE t.pid = c.id AND &#13;
              NOT cycle &#13;
              --AND array_length(exist, 1) &lt; 1000 -- глубина дерева&#13;
)&#13;
SELECT id,  title, kind, pid,  note, measure,dobj&#13;
    FROM children WHERE NOT cycle --ORDER BY ord LIMIT 100;&#13;
    );&#13;
END; &#13;
$$
  LANGUAGE plpgsql STABLE 
  COST 1000
  ROWS 1000;</src>
    </Proc>
    <Proc nm="get_path_cls(_cid bigint, _cpid bigint)">
      <src>CREATE OR REPLACE FUNCTION get_path_cls(_cid bigint, _cpid bigint) 
  RETURNS text AS 
$$ &#13;
    SELECT path FROM get_path_cls_info($1,$2) WHERE pid=$2;&#13;
$$
  LANGUAGE sql STABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="get_path_cls_arr_id(_cid bigint, _cpid bigint)">
      <src>CREATE OR REPLACE FUNCTION get_path_cls_arr_id(_cid bigint, _cpid bigint) 
  RETURNS bigint[] AS 
$$ &#13;
    SELECT arr_id FROM get_path_cls_info($1,$2) WHERE pid=$2;&#13;
$$
  LANGUAGE sql STABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="get_path_cls_arr_title(_cid bigint, _cpid bigint)">
      <src>CREATE OR REPLACE FUNCTION get_path_cls_arr_title(_cid bigint, _cpid bigint) 
  RETURNS name[] AS 
$$ &#13;
    SELECT arr_title FROM get_path_cls_info($1,$2) WHERE pid=$2;&#13;
$$
  LANGUAGE sql STABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="get_path_cls_info(IN _cid bigint, IN _cpid bigint)">
      <src>CREATE OR REPLACE FUNCTION get_path_cls_info(IN _cid bigint, IN _cpid bigint) 
  RETURNS TABLE(id bigint, pid bigint, measure whname, kind smallint, title whname, note text, dobj bigint, arr_id bigint[], arr_title name[], path text, cycle boolean) AS 
$$ &#13;
BEGIN&#13;
RETURN QUERY &#13;
  WITH RECURSIVE parents AS &#13;
    (SELECT c.id, c.pid, c.measure, c.kind, c.title, c.note, c.dobj&#13;
          , ARRAY[c.id] AS arr_id&#13;
          , ARRAY[c.title]::NAME[] AS arr_title&#13;
          , '/'||c.title AS path&#13;
          ,FALSE AS cycle&#13;
       FROM acls c&#13;
       WHERE --c.id=333 &#13;
        _cid IS NOT NULL AND _cid&gt;0 AND c.id = _cid &#13;
       UNION ALL&#13;
       SELECT n.id, n.pid, NULL::WHNAME , n.kind, n.title, n.note, NULL&#13;
            , p.arr_id     || ARRAY[n.id]::BIGINT[]&#13;
            , p.arr_title  || ARRAY[n.title]::NAME[]&#13;
            , '/'||n.title|| p.path&#13;
            , n.id = any (p.arr_id) AS CYCLE&#13;
         FROM parents AS p &#13;
         LEFT JOIN acls n ON p.pid=n.id&#13;
         WHERE NOT p.cycle &#13;
               AND n.id &lt;&gt; _cpid --AND n.id &gt; 0&#13;
     )&#13;
     SELECT  * FROM parents WHERE NOT parents.CYCLE;&#13;
&#13;
END; &#13;
$$
  LANGUAGE plpgsql STABLE 
  COST 100
  ROWS 1000;</src>
    </Proc>
    <Proc nm="get_path_obj(_oid bigint, _opid bigint)">
      <src>CREATE OR REPLACE FUNCTION get_path_obj(_oid bigint, _opid bigint) 
  RETURNS text AS 
$$ &#13;
    SELECT path FROM get_path_obj_info($1,$2) WHERE opid=$2;&#13;
$$
  LANGUAGE sql STABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="get_path_obj_arr_2id(_oid bigint, _opid bigint)">
      <src>CREATE OR REPLACE FUNCTION get_path_obj_arr_2id(_oid bigint, _opid bigint) 
  RETURNS bigint[] AS 
$$ &#13;
    SELECT arr_2id FROM get_path_obj_info($1,$2) WHERE opid=$2;&#13;
$$
  LANGUAGE sql STABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="get_path_obj_arr_2title(_oid bigint, _opid bigint)">
      <src>CREATE OR REPLACE FUNCTION get_path_obj_arr_2title(_oid bigint, _opid bigint) 
  RETURNS name[] AS 
$$ &#13;
    SELECT arr_2title FROM get_path_obj_info($1,$2) WHERE opid=$2;&#13;
$$
  LANGUAGE sql STABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="get_path_obj_arr_id(_oid bigint, _opid bigint)">
      <src>CREATE OR REPLACE FUNCTION get_path_obj_arr_id(_oid bigint, _opid bigint) 
  RETURNS bigint[] AS 
$$ &#13;
    SELECT arr_id FROM get_path_obj_info($1,$2) WHERE opid=$2;&#13;
$$
  LANGUAGE sql STABLE 
  COST 100;</src>
    </Proc>
    <Proc nm="get_path_obj_info(IN _oid bigint, IN _opid bigint)">
      <src>CREATE OR REPLACE FUNCTION get_path_obj_info(IN _oid bigint, IN _opid bigint) 
  RETURNS TABLE(oid bigint, opid bigint, otitle whname, cid bigint, ctitle whname, arr_id bigint[], arr_2id bigint[], arr_2title name[], path text, cycle boolean) AS 
$$ &#13;
BEGIN&#13;
RETURN QUERY &#13;
    WITH RECURSIVE parents AS &#13;
    (SELECT o.id, o.pid &#13;
          , o.title&#13;
          , c.id, c.title&#13;
          , ARRAY[o.id]::BIGINT[] AS arr_id&#13;
          , ARRAY[ ARRAY[c.id,o.id]::BIGINT[] ]::BIGINT[] AS arr_2id&#13;
          , ARRAY[ ARRAY[c.title,o.title]::NAME[] ]::NAME[] AS arr_2title&#13;
          , '/['||c.title||']'||o.title AS path&#13;
          , FALSE AS CYCLE&#13;
        FROM obj AS o&#13;
        LEFT JOIN acls c ON c.id=o.cls_id&#13;
          WHERE _oid IS NOT NULL AND o.id = _oid AND o.id&gt;0&#13;
     UNION ALL&#13;
     SELECT o.id, o.pid &#13;
          , onm.title&#13;
          , c.id, c.title&#13;
          , p.arr_id     || ARRAY[o.id]::BIGINT[]&#13;
          , p.arr_2id    || ARRAY[c.id,o.id]::BIGINT[]&#13;
          , p.arr_2title || ARRAY[c.title,onm.title]::NAME[]&#13;
          , '/['||c.title||']'||onm.title|| p.path&#13;
          , o.id = any (p.arr_id) AS CYCLE&#13;
        FROM &#13;
        parents AS p&#13;
        LEFT JOIN obj_num AS o ON o.id = p.pid&#13;
        LEFT JOIN obj_name AS onm ON onm.id = o.id&#13;
        LEFT JOIN acls c ON onm.cls_id=c.id AND c.kind BETWEEN 1 AND 3&#13;
        WHERE NOT p.CYCLE&#13;
              AND o.id &lt;&gt; _opid --AND o.id&gt;0&#13;
        )&#13;
   SELECT * FROM parents WHERE NOT parents.CYCLE;&#13;
&#13;
END; &#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 1000
  ROWS 1000;</src>
    </Proc>
    <Proc nm="gin_extract_query_trgm(text, internal, smallint, internal, internal, internal, internal)">
      <src>CREATE OR REPLACE FUNCTION gin_extract_query_trgm(text, internal, smallint, internal, internal, internal, internal) 
  RETURNS internal AS 
$$'$libdir/pg_trgm', 'gin_extract_query_trgm'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="gin_extract_value_trgm(text, internal)">
      <src>CREATE OR REPLACE FUNCTION gin_extract_value_trgm(text, internal) 
  RETURNS internal AS 
$$'$libdir/pg_trgm', 'gin_extract_value_trgm'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="gin_trgm_consistent(internal, smallint, text, integer, internal, internal, internal, internal)">
      <src>CREATE OR REPLACE FUNCTION gin_trgm_consistent(internal, smallint, text, integer, internal, internal, internal, internal) 
  RETURNS boolean AS 
$$'$libdir/pg_trgm', 'gin_trgm_consistent'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="gtrgm_compress(internal)">
      <src>CREATE OR REPLACE FUNCTION gtrgm_compress(internal) 
  RETURNS internal AS 
$$'$libdir/pg_trgm', 'gtrgm_compress'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="gtrgm_consistent(internal, text, integer, oid, internal)">
      <src>CREATE OR REPLACE FUNCTION gtrgm_consistent(internal, text, integer, oid, internal) 
  RETURNS boolean AS 
$$'$libdir/pg_trgm', 'gtrgm_consistent'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="gtrgm_decompress(internal)">
      <src>CREATE OR REPLACE FUNCTION gtrgm_decompress(internal) 
  RETURNS internal AS 
$$'$libdir/pg_trgm', 'gtrgm_decompress'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="gtrgm_distance(internal, text, integer, oid)">
      <src>CREATE OR REPLACE FUNCTION gtrgm_distance(internal, text, integer, oid) 
  RETURNS double precision AS 
$$'$libdir/pg_trgm', 'gtrgm_distance'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="gtrgm_in(cstring)">
      <src>CREATE OR REPLACE FUNCTION gtrgm_in(cstring) 
  RETURNS gtrgm AS 
$$'$libdir/pg_trgm', 'gtrgm_in'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="gtrgm_out(gtrgm)">
      <src>CREATE OR REPLACE FUNCTION gtrgm_out(gtrgm) 
  RETURNS cstring AS 
$$'$libdir/pg_trgm', 'gtrgm_out'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="gtrgm_penalty(internal, internal, internal)">
      <src>CREATE OR REPLACE FUNCTION gtrgm_penalty(internal, internal, internal) 
  RETURNS internal AS 
$$'$libdir/pg_trgm', 'gtrgm_penalty'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="gtrgm_picksplit(internal, internal)">
      <src>CREATE OR REPLACE FUNCTION gtrgm_picksplit(internal, internal) 
  RETURNS internal AS 
$$'$libdir/pg_trgm', 'gtrgm_picksplit'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="gtrgm_same(gtrgm, gtrgm, internal)">
      <src>CREATE OR REPLACE FUNCTION gtrgm_same(gtrgm, gtrgm, internal) 
  RETURNS internal AS 
$$'$libdir/pg_trgm', 'gtrgm_same'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="gtrgm_union(bytea, internal)">
      <src>CREATE OR REPLACE FUNCTION gtrgm_union(bytea, internal) 
  RETURNS integer[] AS 
$$'$libdir/pg_trgm', 'gtrgm_union'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="lock_for_act(_oid bigint, _opid bigint)">
      <src>CREATE OR REPLACE FUNCTION lock_for_act(_oid bigint, _opid bigint) 
  RETURNS SETOF act AS 
$$&#13;
DECLARE&#13;
    _acts CURSOR(_curr_path TEXT, _cls_id BIGINT) IS&#13;
    SELECT act.* from (&#13;
    SELECT perm.act_id , sum(access_disabled) &#13;
        FROM perm_act perm&#13;
        --RIGHT JOIN wh_membership ON groupname=perm.access_group AND wh_membership.username=CURRENT_USER&#13;
      WHERE&#13;
        perm.cls_id IN(SELECT id FROM get_path_cls_info(_cls_id,0))&#13;
        AND (obj_id IS NULL OR obj_id = _oid)&#13;
        AND _curr_path LIKE src_path&#13;
        AND perm.access_group IN (SELECT groupname FROM wh_membership WHERE username=CURRENT_USER)&#13;
      GROUP BY act_id&#13;
      ) t &#13;
      LEFT JOIN act ON t.act_id= act.id &#13;
      WHERE t.sum=0;&#13;
&#13;
&#13;
    _cls_id   BIGINT;&#13;
    _txt_curr_path_2id TEXT;&#13;
&#13;
    _locked_rec   RECORD;&#13;
BEGIN&#13;
-- пытаемся найти объект и его местоположение&#13;
  SELECT cls_id INTO _cls_id FROM obj WHERE id=_oid AND pid = _opid;&#13;
  IF NOT FOUND THEN&#13;
    RAISE EXCEPTION ' Object not exists obj_id=% ', _oid;&#13;
  END IF;&#13;
  -- пытаемся заблокировать объект, если блокировка не удастся транзакция откатится исключением&#13;
  _locked_rec := try_lock_obj(_oid, _opid);&#13;
  -- объект блокирован&#13;
  -- определяем разрешенные действия и спихиваем их в выходную табличку и в табличку блокировки&#13;
  _txt_curr_path_2id := COALESCE(get_path_obj_arr_2id(_opid), '{}');&#13;
  -- RAISE DEBUG ' _curr_path=%    _cls_id=%', _txt_curr_path_2id,_cls_id ;&#13;
  FOR rec IN _acts( _txt_curr_path_2id, _cls_id) LOOP&#13;
    return next rec;                        -- заполняем табличку разрешённых действий&#13;
    -- заполняем табличку идентификаторов разрешённых действий &#13;
    INSERT INTO lock_act(oid, pid, act_id)VALUES (_oid, _opid, rec.id);&#13;
  END LOOP;&#13;
  -- если не нашлись действия, то отпускаем блокировку&#13;
  IF NOT FOUND THEN &#13;
    PERFORM lock_reset(_oid,_opid);&#13;
    RAISE DEBUG ' There are no action, lock aborted';&#13;
  ELSE&#13;
    RAISE DEBUG ' Object LOCKED cls_id=% obj_id=% ',_cls_id, _oid;&#13;
  END IF;&#13;
    &#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 500
  ROWS 1000;</src>
    </Proc>
    <Proc nm="lock_for_move(IN _obj_id bigint, IN _old_pid bigint)">
      <src>CREATE OR REPLACE FUNCTION lock_for_move(IN _obj_id bigint, IN _old_pid bigint) 
  RETURNS TABLE(_dst_obj_id bigint, _dst_cls_id bigint, _dst_obj_label name, _dst_obj_pid bigint, _oiddstpath bigint[]) AS 
$$&#13;
DECLARE&#13;
   _dst_path_2id BIGINT[];&#13;
   _locked_rec RECORD;&#13;
   _cls_id      BIGINT;&#13;
   &#13;
    _dst_obj CURSOR IS&#13;
        SELECT dst_oid, dst_cid, dst_otitle,dst_opid&#13;
        FROM (&#13;
              SELECT &#13;
                dst_oid, dst_cid, dst_otitle ,dst_opid, sum(perm_access_disabled)&#13;
                FROM moverule_lockup WHERE&#13;
                    ocid = _cls_id &#13;
                AND opid = _old_pid&#13;
                AND oid  = _obj_id&#13;
                GROUP BY dst_oid, dst_cid, dst_otitle ,dst_opid&#13;
             )t&#13;
            WHERE sum=0;&#13;
&#13;
BEGIN&#13;
  -- пытаемся найти объект и его местоположение&#13;
  SELECT cls_id INTO _cls_id FROM obj WHERE id=_obj_id AND pid=_old_pid;&#13;
  IF NOT FOUND THEN&#13;
    RAISE EXCEPTION ' Object not exists obj_id=% ', _obj_id;&#13;
  END IF;&#13;
  -- пытаемся заблокировать объект, если блокировка не удастся транзакция откатится исключением&#13;
  _locked_rec := try_lock_obj(_obj_id, _old_pid);&#13;
-- объект блокирован&#13;
-- возвращаем пользвателю объекты назначения, попутно складываем их местоположение  в табличку&#13;
  FOR rec IN _dst_obj LOOP&#13;
    _dst_path_2id := (SELECT get_path_obj_arr_2id(rec.dst_oid));&#13;
    _dst_path_2id:=COALESCE(_dst_path_2id::TEXT,'{}');&#13;
&#13;
    INSERT INTO lock_dst(oid,pid, dst_path)VALUES(_obj_id,_old_pid,_dst_path_2id); &#13;
&#13;
    _dst_obj_id:=rec.dst_oid;&#13;
    _dst_cls_id:=rec.dst_cid;&#13;
    _dst_obj_label:=rec.dst_otitle;&#13;
    _dst_obj_pid:=rec.dst_opid;&#13;
    &#13;
    RETURN NEXT;&#13;
  END LOOP;&#13;
&#13;
  RETURN;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 500
  ROWS 1000;</src>
    </Proc>
    <Proc nm="lock_reset(_oid bigint, _pid bigint)">
      <src>CREATE OR REPLACE FUNCTION lock_reset(_oid bigint, _pid bigint) 
  RETURNS void AS 
$$&#13;
    DELETE FROM lock_obj &#13;
    WHERE &#13;
    lock_session=pg_backend_pid() AND oid=_oid AND pid=_pid ;&#13;
    --AND (&#13;
    --        ((SELECT cls_kind FROM obj WHERE id=_oid) &gt; 1 AND pid=_pid )&#13;
    --      OR (SELECT cls_kind FROM obj WHERE id=_oid) = 1&#13;
    --    );&#13;
$$
  LANGUAGE sql VOLATILE 
  COST 500;</src>
    </Proc>
    <Proc nm="obj_arr_id_to_obj_info(IN idpath anyarray)">
      <src>CREATE OR REPLACE FUNCTION obj_arr_id_to_obj_info(IN idpath anyarray) 
  RETURNS TABLE(arr_2title name[], path text) AS 
$$&#13;
DECLARE&#13;
    --rec      RECORD;&#13;
    --path     TEXT;&#13;
    --result   NAME [];&#13;
    get_obj_info CURSOR IS &#13;
    SELECT cls.id AS cls_id&#13;
        , cls.title::NAME AS cls_title&#13;
        , obj.id AS obj_id&#13;
        , obj.title::NAME AS obj_title&#13;
        ,  arr.id&#13;
        FROM fn_array1_to_table(idpath) arr&#13;
        LEFT JOIN obj_name obj ON obj.id=arr.id&#13;
        LEFT JOIN acls cls ON cls.id=obj.cls_id &#13;
        ORDER BY idx;&#13;
BEGIN&#13;
    path:='';&#13;
    FOR rec IN get_obj_info LOOP&#13;
        arr_2title := arr_2title || ARRAY[ ARRAY[rec.cls_title,rec.obj_title] ];&#13;
        path:=  '/['||COALESCE(rec.cls_title,'')||']'||COALESCE(rec.obj_title,'') || path;&#13;
    END LOOP;&#13;
    RETURN next;&#13;
    RETURN;&#13;
END;&#13;
$$
  LANGUAGE plpgsql STABLE 
  COST 100
  ROWS 1000;</src>
    </Proc>
    <Proc nm="set_limit(real)">
      <src>CREATE OR REPLACE FUNCTION set_limit(real) 
  RETURNS real AS 
$$'$libdir/pg_trgm', 'set_limit'$$
  LANGUAGE c VOLATILE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="show_limit()">
      <src>CREATE OR REPLACE FUNCTION show_limit() 
  RETURNS real AS 
$$'$libdir/pg_trgm', 'show_limit'$$
  LANGUAGE c STABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="show_trgm(text)">
      <src>CREATE OR REPLACE FUNCTION show_trgm(text) 
  RETURNS text[] AS 
$$'$libdir/pg_trgm', 'show_trgm'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="similarity(text, text)">
      <src>CREATE OR REPLACE FUNCTION similarity(text, text) 
  RETURNS real AS 
$$'$libdir/pg_trgm', 'similarity'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="similarity_dist(text, text)">
      <src>CREATE OR REPLACE FUNCTION similarity_dist(text, text) 
  RETURNS real AS 
$$'$libdir/pg_trgm', 'similarity_dist'$$
  LANGUAGE c IMMUTABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="similarity_op(text, text)">
      <src>CREATE OR REPLACE FUNCTION similarity_op(text, text) 
  RETURNS boolean AS 
$$'$libdir/pg_trgm', 'similarity_op'$$
  LANGUAGE c STABLE STRICT
  COST 1;</src>
    </Proc>
    <Proc nm="tmppath_to_2id_info(IN tpath text, IN offset_qty bigint)">
      <src>CREATE OR REPLACE FUNCTION tmppath_to_2id_info(IN tpath text, IN offset_qty bigint) 
  RETURNS TABLE(arr_2title name[], arr_2id bigint[], path text) AS 
$$&#13;
DECLARE&#13;
    _unpackpath CURSOR IS &#13;
    SELECT cls.id AS cls_id&#13;
        , cls.title::NAME AS cls_title&#13;
        , obj.id AS obj_id&#13;
        , obj.title::NAME AS obj_title&#13;
        --,  arr.id1 ,  arr.id2&#13;
        FROM (&#13;
                SELECT ORDINALITY as ord,res[1] as id1,res[2] as id2&#13;
                FROM &#13;
                     regexp_matches( substring($1 from '{(.+)}' ),  &#13;
                     '%+|{(%|[[:digit:]]+),(%|[[:digit:]]+)}','g') WITH ORDINALITY res&#13;
&#13;
             ) arr&#13;
        LEFT JOIN obj_name obj ON obj.id= CASE WHEN arr.id2='%' THEN NULL ELSE arr.id2::BIGINT END&#13;
        LEFT JOIN acls cls ON cls.id= CASE &#13;
                                            WHEN arr.id1 IS NULL OR arr.id1='%'&#13;
                                            THEN obj.cls_id&#13;
                                            ELSE arr.id1::BIGINT END&#13;
        ORDER BY arr.ord DESC OFFSET offset_qty;&#13;
&#13;
BEGIN&#13;
    path:='';&#13;
    FOR rec IN _unpackpath LOOP&#13;
        arr_2title := ARRAY[ ARRAY[rec.cls_title,rec.obj_title] ] || arr_2title;&#13;
        arr_2id :=  ARRAY[ ARRAY[rec.cls_id,rec.obj_id]::BIGINT[] ]::BIGINT[] || arr_2id;&#13;
        path:=  path || '/['||COALESCE(rec.cls_title,'')||']'||COALESCE(rec.obj_title,'');&#13;
    END LOOP;&#13;
    RETURN next;&#13;
    RETURN;&#13;
END;&#13;
$$
  LANGUAGE plpgsql STABLE 
  COST 100
  ROWS 1000;</src>
    </Proc>
    <Proc nm="try_lock_obj(_oid bigint, _pid bigint)">
      <src>CREATE OR REPLACE FUNCTION try_lock_obj(_oid bigint, _pid bigint) 
  RETURNS record AS 
$$&#13;
DECLARE&#13;
    _locked_rec RECORD;&#13;
    _obj_rec RECORD;&#13;
BEGIN&#13;
  -- удаляем просроченые и свои же блокировки на объект, если таковые имеются&#13;
  DELETE &#13;
    FROM lock_obj&#13;
    WHERE oid=_oid AND pid=_pid&#13;
    AND ( lock_time +'00:10:00.00' &lt; now() OR lock_session = pg_backend_pid());&#13;
-- Ищем блокируемый объект в табличке объектов&#13;
  SELECT id,pid,get_path_obj_arr_2id(pid) AS path INTO _obj_rec &#13;
    FROM obj &#13;
    WHERE id=_oid AND pid=_pid;&#13;
  --RAISE DEBUG 'try_lock_obj: finded object %',_obj_rec;&#13;
-- пытаемся вставить в табличку блокировок, если уже блокирован, то исключение откатит транзакцию&#13;
  _obj_rec.path := COALESCE(_obj_rec.path, '{}');&#13;
&#13;
  IF FOUND THEN&#13;
    INSERT INTO lock_obj(oid,pid,path) &#13;
      VALUES (_obj_rec.id,_obj_rec.pid,_obj_rec.path) RETURNING * INTO _locked_rec;&#13;
    --RAISE DEBUG 'try_lock_obj: inserted object %',_locked_rec;&#13;
    RETURN _locked_rec;&#13;
  END IF;&#13;
  RETURN NULL;&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 500;</src>
    </Proc>
    <Proc nm="whgrant_grouptouser(_role name, _user name)">
      <src>CREATE OR REPLACE FUNCTION whgrant_grouptouser(_role name, _user name) 
  RETURNS void AS 
$$	&#13;
DECLARE&#13;
  _role_id INTEGER;&#13;
  _user_id INTEGER;&#13;
BEGIN&#13;
  --RAISE NOTICE USING MESSAGE = 'IN_role='||_role||'  IN_user='||_user;&#13;
  SELECT id INTO _role_id FROM wh_role WHERE wh_role.rolname=_role;&#13;
  SELECT id INTO _user_id FROM wh_role WHERE wh_role.rolname=_user;&#13;
&#13;
  PERFORM FROM wh_auth_members WHERE roleid=_role_id AND member=_user_id;&#13;
  IF NOT FOUND THEN&#13;
    IF _role_id IS NOT NULL AND _user_id IS NOT NULL THEN&#13;
      RAISE NOTICE 'Add User %[%] to group %[%]',_user,_user_id,_role,_role_id;&#13;
      INSERT INTO wh_auth_members(roleid,member)VALUES(_role_id,_user_id);&#13;
    END IF;&#13;
  ELSE&#13;
    RAISE NOTICE 'User % already in group %',_user,_role;&#13;
  END IF;&#13;
&#13;
END;&#13;
$$
  LANGUAGE plpgsql VOLATILE 
  COST 100;</src>
    </Proc>
    <View nm="log">
      <Sql>SELECT
    lm.id AS log_id,
    lm.timemark AS log_dt,
    lm.username AS log_user,
    CASE WHEN lad.act_id IS NOT NULL THEN lad.act_id ELSE NULL::bigint END AS act_id,
    act.title AS act_title,
    act.color AS act_color,
    lm.obj_id AS mobj_id,
    mobj.cls_id AS mcls_id,
    mobj.title AS mobj_title,
    mcls.title AS mcls_title,
    CASE WHEN mcls.kind = 1 THEN 1::numeric ELSE lmd.qty END AS qty,
    CASE WHEN lad.act_id IS NOT NULL THEN lad.prop ELSE NULL::jsonb END AS prop,
    lm.timemark::date AS log_date,
    date_trunc('second'::text,
    lm.timemark)::time without time zone AS log_time,
    lm.src_path[1][1] AS src_cid,
    lm.src_path[1][2] AS src_oid,
    CASE WHEN lad.act_id IS NOT NULL THEN NULL::bigint ELSE lmd.dst_path[1][1] END AS dst_cid,
    CASE WHEN lad.act_id IS NOT NULL THEN NULL::bigint ELSE lmd.dst_path[1][2] END AS dst_oid,
    lm.src_path AS src_ipath,
    CASE WHEN lad.act_id IS NOT NULL THEN NULL::bigint[] ELSE lmd.dst_path END AS dst_ipath,
    ( SELECT tmppath_to_2id_info.path
FROM tmppath_to_2id_info(lm.src_path::text,
    1::bigint) tmppath_to_2id_info(arr_2title,
    arr_2id,
    path)) AS src_path,
    ( SELECT tmppath_to_2id_info.path
FROM tmppath_to_2id_info(lmd.dst_path::text,
    1::bigint) tmppath_to_2id_info(arr_2title,
    arr_2id,
    path)) AS dst_path
FROM log_main lm LEFT
    JOIN log_detail_act lad ON lad.id = lm.id LEFT
    JOIN log_detail_move lmd ON lmd.id = lm.id LEFT
    JOIN act ON act.id = lad.act_id LEFT
    JOIN obj_name mobj ON mobj.id = lm.obj_id LEFT
    JOIN acls mcls ON mcls.id = mobj.cls_id</Sql>
    </View>
    <View nm="log2">
      <Sql>SELECT
    lm.id AS log_id,
    lm.timemark AS log_dt,
    lm.username AS log_user,
    det.act_id,
    act.title AS act_title,
    act.color AS act_color,
    lm.obj_id AS mobj_id,
    mobj.cls_id AS mcls_id,
    mobj.title AS mobj_title,
    mcls.title AS mcls_title,
    det.qty,
    det.prop,
    lm.timemark::date AS log_date,
    date_trunc('second'::text,
    lm.timemark)::time without time zone AS log_time,
    lm.src_path[1][1] AS src_cid,
    lm.src_path[1][2] AS src_oid,
    det.dst_path[1][1] AS dst_cid,
    det.dst_path[1][2] AS dst_oid,
    lm.src_path AS src_ipath,
    det.dst_path AS dst_ipath,
    path.src AS src_path,
    path.dst AS dst_path
FROM log_main lm LEFT
    JOIN ( SELECT lad.id,
    lad.act_id,
    lad.prop,
    NULL::bigint[] AS dst_path,
    1::numeric AS qty,
    lad.id AS prop_lid
FROM log_detail_act lad UNION ALL SELECT lmd.id,
    NULL::bigint AS act_id,
    lad.prop,
    lmd.dst_path,
    lmd.qty,
    lmd.prop_lid
FROM log_detail_move lmd LEFT
    JOIN log_detail_act lad ON lad.id = lmd.prop_lid) det ON lm.id = det.id LEFT
    JOIN act ON act.id = det.act_id LEFT
    JOIN obj_name mobj ON mobj.id = lm.obj_id LEFT
    JOIN acls mcls ON mcls.id = mobj.cls_id LEFT
    JOIN LATERAL ( SELECT ( SELECT tmppath_to_2id_info.path
FROM tmppath_to_2id_info(lm.src_path::text,
    1::bigint) tmppath_to_2id_info(arr_2title,
    arr_2id,
    path)) AS src,
    ( SELECT tmppath_to_2id_info.path
FROM tmppath_to_2id_info(det.dst_path::text,
    1::bigint) tmppath_to_2id_info(arr_2title,
    arr_2id,
    path)) AS dst) path ON true</Sql>
    </View>
    <View nm="moverule_lockup">
      <Sql>SELECT
    mov.id AS oid,
    mov.pid AS opid,
    mov.cls_id AS ocid,
    dst.id AS dst_oid,
    dst.cls_id AS dst_cid,
    dst_name.title AS dst_otitle,
    dst.pid AS dst_opid,
    perm.access_disabled AS perm_access_disabled
FROM ( SELECT perm_1.id,
    perm_1.access_group,
    perm_1.access_disabled,
    perm_1.script_restrict,
    perm_1.src_cls_id,
    perm_1.src_cls_kind,
    perm_1.src_obj_id,
    perm_1.src_path,
    perm_1.cls_id,
    perm_1.obj_id,
    perm_1.dst_cls_id,
    perm_1.dst_cls_kind,
    perm_1.dst_obj_id,
    perm_1.dst_path
FROM perm_move perm_1
WHERE (perm_1.access_group IN ( SELECT wh_membership.groupname
FROM wh_membership
WHERE wh_membership.username = "current_user"()))) perm RIGHT
    JOIN obj mov ON (mov.cls_id IN ( SELECT get_childs_cls._id
FROM get_childs_cls(perm.cls_id) get_childs_cls(_id,
    _title,
    _kind,
    _pid,
    _note,
    _measure,
    _dobj)))
        AND (perm.obj_id = mov.id
        OR perm.obj_id IS NULL) RIGHT
    JOIN obj_num src ON src.id = mov.pid
        AND perm.src_cls_id = src.cls_id
        AND (perm.src_obj_id = src.id
        OR perm.src_obj_id IS NULL)
        AND (src.pid = 0
        AND perm.src_path::text = '{}'::text
        OR get_path_obj_arr_2id(src.pid)::text ~~ perm.src_path::text) RIGHT
    JOIN obj_num dst ON perm.dst_cls_id = dst.cls_id
        AND (perm.dst_obj_id = dst.id
        OR perm.dst_obj_id IS NULL)
        AND (dst.pid = 0
        AND perm.dst_path::text = '{}'::text
        OR get_path_obj_arr_2id(dst.pid)::text ~~ perm.dst_path::text) LEFT
    JOIN obj_name dst_name ON dst_name.id = dst.id
WHERE mov.pid &lt;&gt; dst.id
        AND dst.id &gt; 0</Sql>
    </View>
    <View nm="obj">
      <Sql>SELECT
    cdif.id,
    cdif.pid,
    obj_name.title,
    cdif.cls_id,
    obj_name.prop,
    cdif.qty,
    obj_name.move_logid,
    obj_name.act_logid,
    cdif.cls_kind
FROM ( SELECT obj_num.id,
    obj_num.pid,
    1::numeric AS qty,
    obj_num.cls_id,
    obj_num.cls_kind
FROM obj_num UNION ALL SELECT obj_qtyi.id,
    obj_qtyi.pid,
    obj_qtyi.qty,
    obj_qtyi.cls_id,
    obj_qtyi.cls_kind
FROM obj_qtyi UNION ALL SELECT obj_qtyf.id,
    obj_qtyf.pid,
    obj_qtyf.qty,
    obj_qtyf.cls_id,
    obj_qtyf.cls_kind
FROM obj_qtyf) cdif LEFT
    JOIN obj_name USING (id)</Sql>
    </View>
    <View nm="wh_group">
      <Sql>SELECT
    wh_role.id AS groupid,
    wh_role.rolname AS groupname,
    wh_role.rolconnlimit,
    wh_role.rolvaliduntil,
    wh_role.rolcomment
FROM wh_role
WHERE NOT wh_role.rolcanlogin</Sql>
    </View>
    <View nm="wh_membership">
      <Sql>SELECT
    usrgroup.id AS groupid,
    usrgroup.rolname AS groupname,
    wh_role.id AS userid,
    wh_role.rolname AS username
FROM wh_role RIGHT
    JOIN wh_auth_members membership ON membership.member = wh_role.id LEFT
    JOIN wh_role usrgroup ON membership.roleid = usrgroup.id</Sql>
    </View>
    <View nm="wh_user">
      <Sql>SELECT
    wh_role.id AS userid,
    wh_role.rolname AS username,
    wh_role.rolconnlimit,
    wh_role.rolvaliduntil,
    wh_role.rolcomment,
    wh_role.rolcreaterole,
    wh_role.rolpassword
FROM wh_role
WHERE wh_role.rolcanlogin</Sql>
    </View>
    <Seq incr="1" nm="favorite_prop_id_seq"/>
    <Seq incr="1" nm="seq_act_id"/>
    <Seq incr="1" nm="seq_cls_id"/>
    <Seq incr="1" nm="seq_log_id"/>
    <Seq incr="1" nm="seq_obj_id"/>
    <Seq incr="1" nm="seq_perm_id"/>
    <Seq incr="1" nm="seq_prop_cls_id"/>
    <Seq incr="1" nm="seq_prop_id"/>
    <Seq incr="1" nm="seq_ref_act_prop_id"/>
    <Seq incr="1" nm="seq_ref_cls_act_id"/>
    <Seq incr="1" nm="wh_role_id_seq"/>
    <CustomTypes>
      <CustomType id="5002" nm="name"/>
      <CustomType id="5003" nm="tmppath"/>
      <CustomType id="5001" nm="whname"/>
    </CustomTypes>
  </Sch>
  <Dgm nm="diagramA">
    <RnCf ClkAct="true" FtSz="11" lkStgy="KeyToKeyStrategy" zm="1.0">
      <VbCfg>
        <Fg ky="Auto Number" vl="0"/>
        <Fg ky="Check" vl="0"/>
        <Fg ky="Comment" vl="0"/>
        <Fg ky="Data Type" vl="1"/>
        <Fg ky="Default" vl="0"/>
        <Fg ky="ENUM Values" vl="0"/>
        <Fg ky="Length" vl="1"/>
        <Fg ky="Name" vl="1"/>
        <Fg ky="Nullable" vl="0"/>
        <Fg ky="Schema Name" vl="0"/>
        <Fg ky="Signed" vl="0"/>
      </VbCfg>
    </RnCf>
    <DiaProps>
      <Show AllCols="1" FkCols="1" FkNms="0" PkCols="1"/>
      <ErNotation>DbwErNotation</ErNotation>
      <DbTableRectangleFill>HeaderFooterFill</DbTableRectangleFill>
      <svg path=""/>
    </DiaProps>
    <TbGl bkCl="ff996600" sch="public" tbl="acls" x="1424" y="191"/>
    <TbGl bkCl="ff00cc66" sch="public" tbl="obj_name" x="1793" y="196"/>
    <TbGl bkCl="ff00cc66" sch="public" tbl="obj_num" x="2152" y="45"/>
    <TbGl bkCl="ff00cc66" sch="public" tbl="obj_qtyf" x="2160" y="196"/>
    <TbGl bkCl="ff00cc66" sch="public" tbl="obj_qtyi" x="2153" y="326"/>
    <TbGl bkCl="ff00ff00" sch="public" tbl="prop" x="1384" y="530"/>
    <TbGl bkCl="ffff9933" sch="public" tbl="prop_cls" x="1705" y="554"/>
    <TbGl bkCl="ff999999" sch="public" tbl="ref_cls_act" x="1088" y="370"/>
    <TbGl bkCl="ff999999" sch="public" tbl="ref_act_prop" x="1083" y="524"/>
    <TbGl bkCl="ffff0000" sch="public" tbl="act" x="730" y="519"/>
    <TbGl bkCl="ff999999" sch="public" tbl="perm_act" x="778" y="330"/>
    <TbGl bkCl="ff999999" sch="public" tbl="perm_move" x="779" y="35"/>
    <TbGl bkCl="ff999999" sch="public" tbl="wh_auth_members" x="224" y="279"/>
    <TbGl bkCl="ff9999ff" sch="public" tbl="wh_role" x="209" y="122"/>
    <FkGl bkCl="ffcccccc" childEdge="EAST" nm="public.acls.cls_default_objid_fkey" parentEdge="WEST" positioner="ThreeLineUserLinkPositioner">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="SOUTH" nm="public.acls.fk_acls__id_pid" parentEdge="NORTH" positioner="OneLineUserLinkPositioner">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="WEST" nm="public.obj_name.fk_obj__cls" parentEdge="EAST" positioner="OneLineUserLinkPositioner">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="WEST" nm="public.obj_num.fk_objnum__idclsid" parentEdge="EAST" positioner="ThreeLineUserLinkPositioner">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="SOUTH" nm="public.obj_num.obj_num_pid_fkey" parentEdge="NORTH" positioner="OneLineUserLinkPositioner">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="WEST" nm="public.obj_qtyf.fk_objqtyf__id_cid_ckind" parentEdge="EAST" positioner="ThreeLineUserLinkPositioner">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="NORTH" nm="public.obj_qtyf.obj_qtyf_pid_fkey" parentEdge="SOUTH" positioner="OneLineUserLinkPositioner">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="WEST" nm="public.obj_qtyi.fk_objqtyi__id_cid_ckind" parentEdge="EAST" positioner="OneLineUserLinkPositioner">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="NORTH" nm="public.obj_qtyi.obj_qtyi_pid_fkey" parentEdge="SOUTH" positioner="OneLineUserLinkPositioner">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.perm_act.fk_permact__acess_group" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.perm_act.fk_permact_clsact" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.perm_move.fk_permmove__acess_group" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.perm_move.fk_permmove__dstclsid" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.perm_move.fk_permmove__srcclsid" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.prop_cls.fk_propcls__clsid" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.prop_cls.fk_propcls__propid" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.ref_act_prop.fk_refactprop__actid" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.ref_act_prop.fk_refactprop__propid" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.ref_cls_act.fk_refclsact__actid" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.ref_cls_act.fk_refclsact__clsid" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.wh_auth_members.fk_member_wh_auth_members" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.wh_auth_members.fk_roleid_wh_auth_members" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <Notes/>
    <Zones>
      <Zone bkCl="fffffcaa" h="701" nm="Объекты" w="462" x="1723" y="0"/>
      <Zone bkCl="ffccccff" h="541" nm="Пользователи и группы" w="279" x="137" y="83"/>
      <Zone bkCl="ffffcccc" h="606" nm="Разрешения действий" w="210" x="730" y="288"/>
      <Zone bkCl="ffffcc66" h="241" nm="Свойства класса" w="227" x="1661" y="485"/>
      <Zone bkCl="505eeb33" h="266" nm="Свойства объекта" w="322" x="1039" y="325"/>
    </Zones>
  </Dgm>
  <Dgm nm="История">
    <RnCf ClkAct="true" FtSz="11" lkStgy="KeyToKeyStrategy" zm="1.0">
      <VbCfg>
        <Fg ky="Auto Number" vl="0"/>
        <Fg ky="Check" vl="0"/>
        <Fg ky="Comment" vl="0"/>
        <Fg ky="Data Type" vl="1"/>
        <Fg ky="Default" vl="0"/>
        <Fg ky="ENUM Values" vl="0"/>
        <Fg ky="Length" vl="1"/>
        <Fg ky="Name" vl="1"/>
        <Fg ky="Nullable" vl="0"/>
        <Fg ky="Schema Name" vl="0"/>
        <Fg ky="Signed" vl="0"/>
      </VbCfg>
    </RnCf>
    <DiaProps>
      <Show AllCols="1" FkCols="1" FkNms="0" PkCols="1"/>
      <ErNotation>DbwErNotation</ErNotation>
      <DbTableRectangleFill>HeaderFooterFill</DbTableRectangleFill>
      <svg path=""/>
    </DiaProps>
    <TbGl bkCl="ff6666ff" sch="public" tbl="log_main" x="411" y="422"/>
    <TbGl bkCl="ff6666ff" sch="public" tbl="log_detail_move" x="779" y="361"/>
    <TbGl bkCl="ff6666ff" sch="public" tbl="log_detail_act" x="772" y="555"/>
    <TbGl bkCl="ff00cc66" sch="public" tbl="obj_name" x="59" y="448"/>
    <TbGl bkCl="ff996600" sch="public" tbl="acls" x="39" y="27"/>
    <TbGl bkCl="ff999999" sch="public" tbl="wh_auth_members" x="387" y="0"/>
    <TbGl bkCl="ff9999ff" sch="public" tbl="wh_role" x="373" y="58"/>
    <TbGl bkCl="ffff0000" sch="public" tbl="act" x="61" y="590"/>
    <FkGl bkCl="ff000000" childEdge="" nm="public.acls.fk_acls__id_pid" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.log_detail_act.log_detail_act_act_id_fkey" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.log_detail_act.log_detail_act_id_fkey" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.log_detail_move.log_detail_move_id_fkey" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.log_detail_move.log_detail_move_prop_lid_fkey" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.log_main.log_main_obj_id_fkey" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.log_main.log_main_username_fkey" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.obj_name.fk_obj__cls" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.wh_auth_members.fk_member_wh_auth_members" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <FkGl bkCl="ff000000" childEdge="" nm="public.wh_auth_members.fk_roleid_wh_auth_members" parentEdge="" positioner="">
      <positionableLines/>
    </FkGl>
    <Notes/>
    <Zones>
      <Zone bkCl="ffece9d8" h="736" nm="История" w="339" x="338" y="318"/>
    </Zones>
  </Dgm>
  <RnmMgr NxRnmId="1"/>
  <DbDocOptionMgr>
    <BasicOptionMgr>
      <Name>db.doc.option.mgr</Name>
      <BoolOpt lbl="Diagrams" nm="doc.diagrams" on="1" spl="0"/>
      <BoolOpt lbl="Foreign Keys" nm="doc.fks" on="1" spl="0"/>
      <BoolOpt lbl="Indexes" nm="doc.indexes" on="1" spl="0"/>
      <BoolOpt lbl="Overwrite CSS File" nm="doc.overwrite.css" on="1" spl="0"/>
      <BoolOpt lbl="Procedures" nm="doc.procs" on="1" spl="0"/>
      <BoolOpt lbl="Schemas" nm="doc.schemas" on="1" spl="0"/>
      <BoolOpt lbl="Sequences" nm="doc.sequences" on="1" spl="0"/>
      <BoolOpt lbl="Tables" nm="doc.tables" on="1" spl="0"/>
      <BoolOpt lbl="Triggers" nm="doc.triggers" on="1" spl="0"/>
      <BoolOpt lbl="Views" nm="doc.views" on="1" spl="0"/>
    </BasicOptionMgr>
  </DbDocOptionMgr>
  <OpenEditors>
    <OpenEditor ClsNm="Diagram" fqn="null.История" selected="0"/>
    <OpenEditor ClsNm="Diagram" fqn="null.diagramA" selected="1"/>
  </OpenEditors>
  <TreePaths>
    <TreePath/>
    <TreePath>/Schemas (1)</TreePath>
    <TreePath>/Schemas (1)/public</TreePath>
    <TreePath>/Schemas (1)/public/Tables (22)</TreePath>
    <TreePath>/Schemas (1)/public/Tables (22)/obj_name</TreePath>
    <TreePath>/Diagrams (2)</TreePath>
    <TreePath>/Diagrams (2)/diagramA</TreePath>
    <TreePath>/Diagrams (2)/diagramA/Zones (5)</TreePath>
    <TreePath>/Diagrams (2)/История</TreePath>
  </TreePaths>
  <SqlTexts/>
</Db>
